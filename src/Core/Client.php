<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace KatapultAPI\Core;

class Client extends Runtime\Client\Client
{
    /**
     * Returns a list of all API tokens for an organization
     * ## Scopes
     * - `api_tokens`
     * - `api_tokens:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to list API tokens for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to list API tokens for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationApiTokensGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationApiTokensBadRequestException
     * @throws Exception\GetOrganizationApiTokensForbiddenException
     * @throws Exception\GetOrganizationApiTokensNotFoundException
     * @throws Exception\GetOrganizationApiTokensTooManyRequestsException
     * @throws Exception\GetOrganizationApiTokensServiceUnavailableException
     */
    public function getOrganizationApiTokens(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationApiTokens($queryParameters), $fetch);
    }

    /**
     * Create a new API token for a given organization
     * ## Scopes
     * - `api_tokens`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationApiTokensPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationApiTokensBadRequestException
     * @throws Exception\PostOrganizationApiTokensForbiddenException
     * @throws Exception\PostOrganizationApiTokensNotFoundException
     * @throws Exception\PostOrganizationApiTokensUnprocessableEntityException
     * @throws Exception\PostOrganizationApiTokensTooManyRequestsException
     * @throws Exception\PostOrganizationApiTokensServiceUnavailableException
     */
    public function postOrganizationApiTokens(?Model\OrganizationsOrganizationApiTokensPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationApiTokens($requestBody), $fetch);
    }

    /**
     * Delete an organization API token
     * ## Scopes
     * - `api_tokens`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ApiTokensApiTokenDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteApiTokenBadRequestException
     * @throws Exception\DeleteApiTokenForbiddenException
     * @throws Exception\DeleteApiTokenNotFoundException
     * @throws Exception\DeleteApiTokenUnprocessableEntityException
     * @throws Exception\DeleteApiTokenTooManyRequestsException
     * @throws Exception\DeleteApiTokenServiceUnavailableException
     */
    public function deleteApiToken(?Model\ApiTokensApiTokenDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteApiToken($requestBody), $fetch);
    }

    /**
     * Updates an organization API token with new properties
     * ## Scopes
     * - `api_tokens`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ApiTokensApiTokenPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchApiTokenBadRequestException
     * @throws Exception\PatchApiTokenForbiddenException
     * @throws Exception\PatchApiTokenNotFoundException
     * @throws Exception\PatchApiTokenUnprocessableEntityException
     * @throws Exception\PatchApiTokenTooManyRequestsException
     * @throws Exception\PatchApiTokenServiceUnavailableException
     */
    public function patchApiToken(?Model\ApiTokensApiTokenPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchApiToken($requestBody), $fetch);
    }

    /**
     * Regenerates the secret for an organization API token
     * ## Scopes
     * - `api_tokens`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ApiTokensApiTokenRegenerateSecretPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostApiTokenRegenerateSecretBadRequestException
     * @throws Exception\PostApiTokenRegenerateSecretForbiddenException
     * @throws Exception\PostApiTokenRegenerateSecretNotFoundException
     * @throws Exception\PostApiTokenRegenerateSecretUnprocessableEntityException
     * @throws Exception\PostApiTokenRegenerateSecretTooManyRequestsException
     * @throws Exception\PostApiTokenRegenerateSecretServiceUnavailableException
     */
    public function postApiTokenRegenerateSecret(?Model\ApiTokensApiTokenRegenerateSecretPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostApiTokenRegenerateSecret($requestBody), $fetch);
    }

    /**
     * Returns a list of all global address lists.
     * ## Scopes
     * - `address_lists`
     * - `address_lists:read`.
     *
     * @param array $queryParameters {
     *
     * @var int $page
     * @var int $per_page
     *          }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetAddressListsBadRequestException
     * @throws Exception\GetAddressListsForbiddenException
     * @throws Exception\GetAddressListsTooManyRequestsException
     * @throws Exception\GetAddressListsServiceUnavailableException
     */
    public function getAddressLists(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetAddressLists($queryParameters), $fetch);
    }

    /**
     * Returns a list of all address lists for a given organization
     * ## Scopes
     * - `address_lists`
     * - `address_lists:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization for which the address lists should be returned. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization for which the address lists should be returned. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationAddressListsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationAddressListsBadRequestException
     * @throws Exception\GetOrganizationAddressListsForbiddenException
     * @throws Exception\GetOrganizationAddressListsNotFoundException
     * @throws Exception\GetOrganizationAddressListsTooManyRequestsException
     * @throws Exception\GetOrganizationAddressListsServiceUnavailableException
     */
    public function getOrganizationAddressLists(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationAddressLists($queryParameters), $fetch);
    }

    /**
     * Create a new address list for a given organization.
     * ## Scopes
     * - `address_lists`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationAddressListsPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationAddressListsBadRequestException
     * @throws Exception\PostOrganizationAddressListsForbiddenException
     * @throws Exception\PostOrganizationAddressListsNotFoundException
     * @throws Exception\PostOrganizationAddressListsUnprocessableEntityException
     * @throws Exception\PostOrganizationAddressListsTooManyRequestsException
     * @throws Exception\PostOrganizationAddressListsServiceUnavailableException
     */
    public function postOrganizationAddressLists(?Model\OrganizationsOrganizationAddressListsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationAddressLists($requestBody), $fetch);
    }

    /**
     * Delete a address list.
     * ## Scopes
     * - `address_lists`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListsAddressListDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteAddressListBadRequestException
     * @throws Exception\DeleteAddressListForbiddenException
     * @throws Exception\DeleteAddressListNotFoundException
     * @throws Exception\DeleteAddressListTooManyRequestsException
     * @throws Exception\DeleteAddressListServiceUnavailableException
     */
    public function deleteAddressList(?Model\AddressListsAddressListDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteAddressList($requestBody), $fetch);
    }

    /**
     * Returns details for a address list.
     * ## Scopes
     * - `address_lists`
     * - `address_lists:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $address_list[id] The address list to return. All 'address_list[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListsAddressListGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetAddressListBadRequestException
     * @throws Exception\GetAddressListForbiddenException
     * @throws Exception\GetAddressListNotFoundException
     * @throws Exception\GetAddressListTooManyRequestsException
     * @throws Exception\GetAddressListServiceUnavailableException
     */
    public function getAddressList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetAddressList($queryParameters), $fetch);
    }

    /**
     * Update a address list with new properties.
     * ## Scopes
     * - `address_lists`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListsAddressListPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchAddressListBadRequestException
     * @throws Exception\PatchAddressListForbiddenException
     * @throws Exception\PatchAddressListNotFoundException
     * @throws Exception\PatchAddressListUnprocessableEntityException
     * @throws Exception\PatchAddressListTooManyRequestsException
     * @throws Exception\PatchAddressListServiceUnavailableException
     */
    public function patchAddressList(?Model\AddressListsAddressListPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchAddressList($requestBody), $fetch);
    }

    /**
     * Returns a list of all address list entries for a given address list
     * ## Scopes
     * - `address_lists`
     * - `address_lists:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $address_list[id] The address list for which the entries should be returned. All 'address_list[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListsAddressListEntriesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetAddressListEntriesBadRequestException
     * @throws Exception\GetAddressListEntriesForbiddenException
     * @throws Exception\GetAddressListEntriesNotFoundException
     * @throws Exception\GetAddressListEntriesTooManyRequestsException
     * @throws Exception\GetAddressListEntriesServiceUnavailableException
     */
    public function getAddressListEntries(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetAddressListEntries($queryParameters), $fetch);
    }

    /**
     * Create a new address list entry for a given address list.
     * ## Scopes
     * - `address_lists`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListsAddressListEntriesPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostAddressListEntriesBadRequestException
     * @throws Exception\PostAddressListEntriesForbiddenException
     * @throws Exception\PostAddressListEntriesNotFoundException
     * @throws Exception\PostAddressListEntriesUnprocessableEntityException
     * @throws Exception\PostAddressListEntriesTooManyRequestsException
     * @throws Exception\PostAddressListEntriesServiceUnavailableException
     */
    public function postAddressListEntries(?Model\AddressListsAddressListEntriesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostAddressListEntries($requestBody), $fetch);
    }

    /**
     * Delete an address list entry.
     * ## Scopes
     * - `address_lists`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListEntriesAddressListEntryDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteAddressListEntryBadRequestException
     * @throws Exception\DeleteAddressListEntryForbiddenException
     * @throws Exception\DeleteAddressListEntryNotFoundException
     * @throws Exception\DeleteAddressListEntryTooManyRequestsException
     * @throws Exception\DeleteAddressListEntryServiceUnavailableException
     */
    public function deleteAddressListEntry(?Model\AddressListEntriesAddressListEntryDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteAddressListEntry($requestBody), $fetch);
    }

    /**
     * Returns details for an address list entry.
     * ## Scopes
     * - `address_lists`
     * - `address_lists:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $address_list_entry[id] The address list entry to return. All 'address_list_entry[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListEntriesAddressListEntryGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetAddressListEntryBadRequestException
     * @throws Exception\GetAddressListEntryForbiddenException
     * @throws Exception\GetAddressListEntryNotFoundException
     * @throws Exception\GetAddressListEntryTooManyRequestsException
     * @throws Exception\GetAddressListEntryServiceUnavailableException
     */
    public function getAddressListEntry(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetAddressListEntry($queryParameters), $fetch);
    }

    /**
     * Update an address list entry with new properties.
     * ## Scopes
     * - `address_lists`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListEntriesAddressListEntryPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchAddressListEntryBadRequestException
     * @throws Exception\PatchAddressListEntryForbiddenException
     * @throws Exception\PatchAddressListEntryNotFoundException
     * @throws Exception\PatchAddressListEntryUnprocessableEntityException
     * @throws Exception\PatchAddressListEntryTooManyRequestsException
     * @throws Exception\PatchAddressListEntryServiceUnavailableException
     */
    public function patchAddressListEntry(?Model\AddressListEntriesAddressListEntryPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchAddressListEntry($requestBody), $fetch);
    }

    /**
     * Create or delete multiple address list entries for a given address list.
     * ## Scopes
     * - `address_lists`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\AddressListsAddressListEntriesBulkPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostAddressListEntriesBulkBadRequestException
     * @throws Exception\PostAddressListEntriesBulkForbiddenException
     * @throws Exception\PostAddressListEntriesBulkNotFoundException
     * @throws Exception\PostAddressListEntriesBulkUnprocessableEntityException
     * @throws Exception\PostAddressListEntriesBulkTooManyRequestsException
     * @throws Exception\PostAddressListEntriesBulkServiceUnavailableException
     */
    public function postAddressListEntriesBulk(?Model\AddressListsAddressListEntriesBulkPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostAddressListEntriesBulk($requestBody), $fetch);
    }

    /**
     * Provides a full list of certificates
     * ## Scopes
     * - `certificates`
     * - `certificates:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationCertificatesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationCertificatesBadRequestException
     * @throws Exception\GetOrganizationCertificatesForbiddenException
     * @throws Exception\GetOrganizationCertificatesNotFoundException
     * @throws Exception\GetOrganizationCertificatesTooManyRequestsException
     * @throws Exception\GetOrganizationCertificatesServiceUnavailableException
     */
    public function getOrganizationCertificates(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationCertificates($queryParameters), $fetch);
    }

    /**
     * Return details for a specific certificate
     * ## Scopes
     * - `certificates`
     * - `certificates:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $certificate[id] All 'certificate[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\CertificatesCertificateGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetCertificateBadRequestException
     * @throws Exception\GetCertificateForbiddenException
     * @throws Exception\GetCertificateNotFoundException
     * @throws Exception\GetCertificateNotAcceptableException
     * @throws Exception\GetCertificateTooManyRequestsException
     * @throws Exception\GetCertificateServiceUnavailableException
     */
    public function getCertificate(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetCertificate($queryParameters), $fetch);
    }

    /**
     * Return a list of all countries available in Katapult.
     *
     * @param array $queryParameters {
     *
     * @var int $page
     * @var int $per_page
     *          }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\CountriesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetCountriesBadRequestException
     * @throws Exception\GetCountriesForbiddenException
     * @throws Exception\GetCountriesTooManyRequestsException
     * @throws Exception\GetCountriesServiceUnavailableException
     */
    public function getCountries(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetCountries($queryParameters), $fetch);
    }

    /**
     * Return details for a specific country.
     *
     * @param array $queryParameters {
     *
     * @var string $country[id] The country to return. All 'country[]' params are mutually exclusive, only one can be provided.
     * @var string $country[iso_code2] The country to return. All 'country[]' params are mutually exclusive, only one can be provided.
     * @var string $country[iso_code3] The country to return. All 'country[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\CountriesCountryGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetCountryBadRequestException
     * @throws Exception\GetCountryForbiddenException
     * @throws Exception\GetCountryNotFoundException
     * @throws Exception\GetCountryTooManyRequestsException
     * @throws Exception\GetCountryServiceUnavailableException
     */
    public function getCountry(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetCountry($queryParameters), $fetch);
    }

    /**
     * Return a list of all country states for a specific country.
     *
     * @param array $queryParameters {
     *
     * @var string $country[id] The country to return states for. All 'country[]' params are mutually exclusive, only one can be provided.
     * @var string $country[iso_code2] The country to return states for. All 'country[]' params are mutually exclusive, only one can be provided.
     * @var string $country[iso_code3] The country to return states for. All 'country[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\CountriesCountryCountryStatesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetCountryCountryStatesBadRequestException
     * @throws Exception\GetCountryCountryStatesForbiddenException
     * @throws Exception\GetCountryCountryStatesNotFoundException
     * @throws Exception\GetCountryCountryStatesTooManyRequestsException
     * @throws Exception\GetCountryCountryStatesServiceUnavailableException
     */
    public function getCountryCountryStates(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetCountryCountryStates($queryParameters), $fetch);
    }

    /**
     * Return details for a specific country state.
     *
     * @param array $queryParameters {
     *
     * @var string $country_state[id] The country state to return. All 'country_state[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\CountryStatesCountryStateGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetCountryStateBadRequestException
     * @throws Exception\GetCountryStateForbiddenException
     * @throws Exception\GetCountryStateNotFoundException
     * @throws Exception\GetCountryStateTooManyRequestsException
     * @throws Exception\GetCountryStateServiceUnavailableException
     */
    public function getCountryState(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetCountryState($queryParameters), $fetch);
    }

    /**
     * Return a list of all currencies available in Katapult.
     *
     * @param array $queryParameters {
     *
     * @var int $page
     * @var int $per_page
     *          }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\CurrenciesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetCurrenciesBadRequestException
     * @throws Exception\GetCurrenciesForbiddenException
     * @throws Exception\GetCurrenciesTooManyRequestsException
     * @throws Exception\GetCurrenciesServiceUnavailableException
     */
    public function getCurrencies(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetCurrencies($queryParameters), $fetch);
    }

    /**
     * Return details for a specific currency.
     *
     * @param array $queryParameters {
     *
     * @var string $currency[id] The currency to return. All 'currency[]' params are mutually exclusive, only one can be provided.
     * @var string $currency[iso_code] The currency to return. All 'currency[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\CurrenciesCurrencyGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetCurrencyBadRequestException
     * @throws Exception\GetCurrencyForbiddenException
     * @throws Exception\GetCurrencyNotFoundException
     * @throws Exception\GetCurrencyTooManyRequestsException
     * @throws Exception\GetCurrencyServiceUnavailableException
     */
    public function getCurrency(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetCurrency($queryParameters), $fetch);
    }

    /**
     * Return a list of all DNS zones
     * ## Scopes
     * - `dns`
     * - `dns:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDnsZonesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationDnsZonesBadRequestException
     * @throws Exception\GetOrganizationDnsZonesForbiddenException
     * @throws Exception\GetOrganizationDnsZonesNotFoundException
     * @throws Exception\GetOrganizationDnsZonesTooManyRequestsException
     * @throws Exception\GetOrganizationDnsZonesServiceUnavailableException
     */
    public function getOrganizationDnsZones(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationDnsZones($queryParameters), $fetch);
    }

    /**
     * Create a new DNS zone within an existing organization
     * ## Scopes
     * - `dns`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDnsZonesPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationDnsZonesBadRequestException
     * @throws Exception\PostOrganizationDnsZonesForbiddenException
     * @throws Exception\PostOrganizationDnsZonesNotFoundException
     * @throws Exception\PostOrganizationDnsZonesUnprocessableEntityException
     * @throws Exception\PostOrganizationDnsZonesTooManyRequestsException
     * @throws Exception\PostOrganizationDnsZonesServiceUnavailableException
     */
    public function postOrganizationDnsZones(?Model\OrganizationsOrganizationDnsZonesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationDnsZones($requestBody), $fetch);
    }

    /**
     * Return a list of nameservers that should be used for DNS zones within a given organization
     * ## Scopes
     * - `dns`
     * - `dns:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDnsZonesNameserversGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationDnsZonesNameserversBadRequestException
     * @throws Exception\GetOrganizationDnsZonesNameserversForbiddenException
     * @throws Exception\GetOrganizationDnsZonesNameserversNotFoundException
     * @throws Exception\GetOrganizationDnsZonesNameserversTooManyRequestsException
     * @throws Exception\GetOrganizationDnsZonesNameserversServiceUnavailableException
     */
    public function getOrganizationDnsZonesNameservers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationDnsZonesNameservers($queryParameters), $fetch);
    }

    /**
     * Delete a DNS zone
     * ## Scopes
     * - `dns`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsZonesDnsZoneDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteDnsZoneBadRequestException
     * @throws Exception\DeleteDnsZoneForbiddenException
     * @throws Exception\DeleteDnsZoneNotFoundException
     * @throws Exception\DeleteDnsZoneTooManyRequestsException
     * @throws Exception\DeleteDnsZoneServiceUnavailableException
     */
    public function deleteDnsZone(?Model\DnsZonesDnsZoneDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteDnsZone($requestBody), $fetch);
    }

    /**
     * Return details for a specific DNS zone
     * ## Scopes
     * - `dns`
     * - `dns:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $dns_zone[id] All 'dns_zone[]' params are mutually exclusive, only one can be provided
     * @var string $dns_zone[name] All 'dns_zone[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsZonesDnsZoneGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDnsZoneBadRequestException
     * @throws Exception\GetDnsZoneForbiddenException
     * @throws Exception\GetDnsZoneNotFoundException
     * @throws Exception\GetDnsZoneTooManyRequestsException
     * @throws Exception\GetDnsZoneServiceUnavailableException
     */
    public function getDnsZone(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDnsZone($queryParameters), $fetch);
    }

    /**
     * Update properties for a DNS zone
     * ## Scopes
     * - `dns`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsZonesDnsZonePatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchDnsZoneBadRequestException
     * @throws Exception\PatchDnsZoneForbiddenException
     * @throws Exception\PatchDnsZoneNotFoundException
     * @throws Exception\PatchDnsZoneUnprocessableEntityException
     * @throws Exception\PatchDnsZoneTooManyRequestsException
     * @throws Exception\PatchDnsZoneServiceUnavailableException
     */
    public function patchDnsZone(?Model\DnsZonesDnsZonePatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchDnsZone($requestBody), $fetch);
    }

    /**
     * Attempt to verify the nameservers for a given DNS zone
     * ## Scopes
     * - `dns`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsZonesDnsZoneVerifyPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostDnsZoneVerifyBadRequestException
     * @throws Exception\PostDnsZoneVerifyForbiddenException
     * @throws Exception\PostDnsZoneVerifyNotFoundException
     * @throws Exception\PostDnsZoneVerifyUnprocessableEntityException
     * @throws Exception\PostDnsZoneVerifyTooManyRequestsException
     * @throws Exception\PostDnsZoneVerifyServiceUnavailableException
     */
    public function postDnsZoneVerify(?Model\DnsZonesDnsZoneVerifyPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostDnsZoneVerify($requestBody), $fetch);
    }

    /**
     * Return a list of all DNS records in a zone
     * ## Scopes
     * - `dns`
     * - `dns:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $dns_zone[id] All 'dns_zone[]' params are mutually exclusive, only one can be provided
     * @var string $dns_zone[name] All 'dns_zone[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsZonesDnsZoneRecordsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDnsZoneRecordsBadRequestException
     * @throws Exception\GetDnsZoneRecordsForbiddenException
     * @throws Exception\GetDnsZoneRecordsNotFoundException
     * @throws Exception\GetDnsZoneRecordsTooManyRequestsException
     * @throws Exception\GetDnsZoneRecordsServiceUnavailableException
     */
    public function getDnsZoneRecords(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDnsZoneRecords($queryParameters), $fetch);
    }

    /**
     * Create a new DNS record
     * ## Scopes
     * - `dns`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsZonesDnsZoneRecordsPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostDnsZoneRecordsBadRequestException
     * @throws Exception\PostDnsZoneRecordsForbiddenException
     * @throws Exception\PostDnsZoneRecordsNotFoundException
     * @throws Exception\PostDnsZoneRecordsUnprocessableEntityException
     * @throws Exception\PostDnsZoneRecordsTooManyRequestsException
     * @throws Exception\PostDnsZoneRecordsServiceUnavailableException
     */
    public function postDnsZoneRecords(?Model\DnsZonesDnsZoneRecordsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostDnsZoneRecords($requestBody), $fetch);
    }

    /**
     * Delete a DNS record
     * ## Scopes
     * - `dns`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsRecordsDnsRecordDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteDnsRecordBadRequestException
     * @throws Exception\DeleteDnsRecordForbiddenException
     * @throws Exception\DeleteDnsRecordNotFoundException
     * @throws Exception\DeleteDnsRecordTooManyRequestsException
     * @throws Exception\DeleteDnsRecordServiceUnavailableException
     */
    public function deleteDnsRecord(?Model\DnsRecordsDnsRecordDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteDnsRecord($requestBody), $fetch);
    }

    /**
     * Return details for a specific DNS record
     * ## Scopes
     * - `dns`
     * - `dns:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $dns_record[id] All 'dns_record[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsRecordsDnsRecordGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDnsRecordBadRequestException
     * @throws Exception\GetDnsRecordForbiddenException
     * @throws Exception\GetDnsRecordNotFoundException
     * @throws Exception\GetDnsRecordTooManyRequestsException
     * @throws Exception\GetDnsRecordServiceUnavailableException
     */
    public function getDnsRecord(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDnsRecord($queryParameters), $fetch);
    }

    /**
     * Update a DNS record properties
     * ## Scopes
     * - `dns`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DnsRecordsDnsRecordPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchDnsRecordBadRequestException
     * @throws Exception\PatchDnsRecordForbiddenException
     * @throws Exception\PatchDnsRecordNotFoundException
     * @throws Exception\PatchDnsRecordUnprocessableEntityException
     * @throws Exception\PatchDnsRecordTooManyRequestsException
     * @throws Exception\PatchDnsRecordServiceUnavailableException
     */
    public function patchDnsRecord(?Model\DnsRecordsDnsRecordPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchDnsRecord($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DataCentersGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDataCentersBadRequestException
     * @throws Exception\GetDataCentersForbiddenException
     * @throws Exception\GetDataCentersTooManyRequestsException
     * @throws Exception\GetDataCentersServiceUnavailableException
     */
    public function getDataCenters(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDataCenters(), $fetch);
    }

    /**
     * Provide details for a specific data center.
     *
     * @param array $queryParameters {
     *
     * @var string $data_center[id] All 'data_center[]' params are mutually exclusive, only one can be provided
     * @var string $data_center[permalink] All 'data_center[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DataCentersDataCenterGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDataCenterBadRequestException
     * @throws Exception\GetDataCenterForbiddenException
     * @throws Exception\GetDataCenterNotFoundException
     * @throws Exception\GetDataCenterTooManyRequestsException
     * @throws Exception\GetDataCenterServiceUnavailableException
     */
    public function getDataCenter(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDataCenter($queryParameters), $fetch);
    }

    /**
     * Provide details of default network for a data center.
     *
     * @param array $queryParameters {
     *
     * @var string $data_center[id] All 'data_center[]' params are mutually exclusive, only one can be provided
     * @var string $data_center[permalink] All 'data_center[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DataCentersDataCenterDefaultNetworkGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDataCenterDefaultNetworkBadRequestException
     * @throws Exception\GetDataCenterDefaultNetworkForbiddenException
     * @throws Exception\GetDataCenterDefaultNetworkNotFoundException
     * @throws Exception\GetDataCenterDefaultNetworkTooManyRequestsException
     * @throws Exception\GetDataCenterDefaultNetworkServiceUnavailableException
     */
    public function getDataCenterDefaultNetwork(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDataCenterDefaultNetwork($queryParameters), $fetch);
    }

    /**
     * Return a list of all disk IO profiles available to this organization.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to find disk IO profiles for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to find disk IO profiles for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDiskIoProfilesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationDiskIoProfilesBadRequestException
     * @throws Exception\GetOrganizationDiskIoProfilesForbiddenException
     * @throws Exception\GetOrganizationDiskIoProfilesNotFoundException
     * @throws Exception\GetOrganizationDiskIoProfilesTooManyRequestsException
     * @throws Exception\GetOrganizationDiskIoProfilesServiceUnavailableException
     */
    public function getOrganizationDiskIoProfiles(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationDiskIoProfiles($queryParameters), $fetch);
    }

    /**
     * Returns a list of all disk backup policies for a given organization
     * ## Scopes
     * - `disk_backup_policies`
     * - `disk_backup_policies:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to return disk backup policies for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to return disk backup policies for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDiskBackupPoliciesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationDiskBackupPoliciesBadRequestException
     * @throws Exception\GetOrganizationDiskBackupPoliciesForbiddenException
     * @throws Exception\GetOrganizationDiskBackupPoliciesNotFoundException
     * @throws Exception\GetOrganizationDiskBackupPoliciesTooManyRequestsException
     * @throws Exception\GetOrganizationDiskBackupPoliciesServiceUnavailableException
     */
    public function getOrganizationDiskBackupPolicies(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationDiskBackupPolicies($queryParameters), $fetch);
    }

    /**
     * Returns a list of all disk backup policies for a given virtual machine
     * ## Scopes
     * - `disk_backup_policies`
     * - `disk_backup_policies:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine[id] The virtual machine to return disk backup policies for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var string $virtual_machine[fqdn] The virtual machine to return disk backup policies for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var bool   $include_disks If true, the returned list will include backup policies owned by disks assigned to this virtual machine in addition to those that belong to the whole virtual machine
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineDiskBackupPoliciesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineDiskBackupPoliciesBadRequestException
     * @throws Exception\GetVirtualMachineDiskBackupPoliciesForbiddenException
     * @throws Exception\GetVirtualMachineDiskBackupPoliciesNotFoundException
     * @throws Exception\GetVirtualMachineDiskBackupPoliciesNotAcceptableException
     * @throws Exception\GetVirtualMachineDiskBackupPoliciesTooManyRequestsException
     * @throws Exception\GetVirtualMachineDiskBackupPoliciesServiceUnavailableException
     */
    public function getVirtualMachineDiskBackupPolicies(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachineDiskBackupPolicies($queryParameters), $fetch);
    }

    /**
     * Creates a new disk backup policy for a virtual machine
     * ## Scopes
     * - `disk_backup_policies`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineDiskBackupPoliciesPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineDiskBackupPoliciesBadRequestException
     * @throws Exception\PostVirtualMachineDiskBackupPoliciesForbiddenException
     * @throws Exception\PostVirtualMachineDiskBackupPoliciesNotFoundException
     * @throws Exception\PostVirtualMachineDiskBackupPoliciesNotAcceptableException
     * @throws Exception\PostVirtualMachineDiskBackupPoliciesUnprocessableEntityException
     * @throws Exception\PostVirtualMachineDiskBackupPoliciesTooManyRequestsException
     * @throws Exception\PostVirtualMachineDiskBackupPoliciesServiceUnavailableException
     */
    public function postVirtualMachineDiskBackupPolicies(?Model\VirtualMachinesVirtualMachineDiskBackupPoliciesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineDiskBackupPolicies($requestBody), $fetch);
    }

    /**
     * Returns a list of all disk backup policies for a given disk
     * ## Scopes
     * - `disk_backup_policies`
     * - `disk_backup_policies:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $disk[id] The disk to return disk backup policies for. All 'disk[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskDiskBackupPoliciesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDiskDiskBackupPoliciesBadRequestException
     * @throws Exception\GetDiskDiskBackupPoliciesForbiddenException
     * @throws Exception\GetDiskDiskBackupPoliciesNotFoundException
     * @throws Exception\GetDiskDiskBackupPoliciesNotAcceptableException
     * @throws Exception\GetDiskDiskBackupPoliciesTooManyRequestsException
     * @throws Exception\GetDiskDiskBackupPoliciesServiceUnavailableException
     */
    public function getDiskDiskBackupPolicies(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDiskDiskBackupPolicies($queryParameters), $fetch);
    }

    /**
     * Creates a new disk backup policy for a disk
     * ## Scopes
     * - `disk_backup_policies`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskDiskBackupPoliciesPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostDiskDiskBackupPoliciesBadRequestException
     * @throws Exception\PostDiskDiskBackupPoliciesForbiddenException
     * @throws Exception\PostDiskDiskBackupPoliciesNotFoundException
     * @throws Exception\PostDiskDiskBackupPoliciesNotAcceptableException
     * @throws Exception\PostDiskDiskBackupPoliciesUnprocessableEntityException
     * @throws Exception\PostDiskDiskBackupPoliciesTooManyRequestsException
     * @throws Exception\PostDiskDiskBackupPoliciesServiceUnavailableException
     */
    public function postDiskDiskBackupPolicies(?Model\DisksDiskDiskBackupPoliciesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostDiskDiskBackupPolicies($requestBody), $fetch);
    }

    /**
     * Deletes a disk backup policy and moves it to the trash
     * ## Scopes
     * - `disk_backup_policies`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskBackupPoliciesDiskBackupPolicyDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteDiskBackupPolicyBadRequestException
     * @throws Exception\DeleteDiskBackupPolicyForbiddenException
     * @throws Exception\DeleteDiskBackupPolicyNotFoundException
     * @throws Exception\DeleteDiskBackupPolicyNotAcceptableException
     * @throws Exception\DeleteDiskBackupPolicyTooManyRequestsException
     * @throws Exception\DeleteDiskBackupPolicyServiceUnavailableException
     */
    public function deleteDiskBackupPolicy(?Model\DiskBackupPoliciesDiskBackupPolicyDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteDiskBackupPolicy($requestBody), $fetch);
    }

    /**
     * Returns information about a specific disk backup policy
     * ## Scopes
     * - `disk_backup_policies`
     * - `disk_backup_policies:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $disk_backup_policy[id] The disk backup policy to get information for. All 'disk_backup_policy[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskBackupPoliciesDiskBackupPolicyGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDiskBackupPolicyBadRequestException
     * @throws Exception\GetDiskBackupPolicyForbiddenException
     * @throws Exception\GetDiskBackupPolicyNotFoundException
     * @throws Exception\GetDiskBackupPolicyNotAcceptableException
     * @throws Exception\GetDiskBackupPolicyTooManyRequestsException
     * @throws Exception\GetDiskBackupPolicyServiceUnavailableException
     */
    public function getDiskBackupPolicy(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDiskBackupPolicy($queryParameters), $fetch);
    }

    /**
     * Updates the disk backup policy with the provided details
     * ## Scopes
     * - `disk_backup_policies`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskBackupPoliciesDiskBackupPolicyPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchDiskBackupPolicyBadRequestException
     * @throws Exception\PatchDiskBackupPolicyForbiddenException
     * @throws Exception\PatchDiskBackupPolicyNotFoundException
     * @throws Exception\PatchDiskBackupPolicyNotAcceptableException
     * @throws Exception\PatchDiskBackupPolicyUnprocessableEntityException
     * @throws Exception\PatchDiskBackupPolicyTooManyRequestsException
     * @throws Exception\PatchDiskBackupPolicyServiceUnavailableException
     */
    public function patchDiskBackupPolicy(?Model\DiskBackupPoliciesDiskBackupPolicyPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchDiskBackupPolicy($requestBody), $fetch);
    }

    /**
     * Schedules a disk backup policy to be moved to the trash at a specific time. The backup policy will continue to function as normal until this time is reached.
     * ## Scopes
     * - `disk_backup_policies`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskBackupPoliciesDiskBackupPolicyScheduleDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteDiskBackupPolicyScheduleBadRequestException
     * @throws Exception\DeleteDiskBackupPolicyScheduleForbiddenException
     * @throws Exception\DeleteDiskBackupPolicyScheduleNotFoundException
     * @throws Exception\DeleteDiskBackupPolicyScheduleNotAcceptableException
     * @throws Exception\DeleteDiskBackupPolicyScheduleTooManyRequestsException
     * @throws Exception\DeleteDiskBackupPolicyScheduleServiceUnavailableException
     */
    public function deleteDiskBackupPolicySchedule(?Model\DiskBackupPoliciesDiskBackupPolicyScheduleDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteDiskBackupPolicySchedule($requestBody), $fetch);
    }

    /**
     * Return a list of all disk template versions for a specific disk template
     * ## Scopes
     * - `disk_templates`
     * - `disk_templates:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $disk_template[id] The disk template to return the versions for. All 'disk_template[]' params are mutually exclusive, only one can be provided.
     * @var string $disk_template[permalink] The disk template to return the versions for. All 'disk_template[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskTemplatesDiskTemplateVersionsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDiskTemplateVersionsBadRequestException
     * @throws Exception\GetDiskTemplateVersionsForbiddenException
     * @throws Exception\GetDiskTemplateVersionsNotFoundException
     * @throws Exception\GetDiskTemplateVersionsTooManyRequestsException
     * @throws Exception\GetDiskTemplateVersionsServiceUnavailableException
     */
    public function getDiskTemplateVersions(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDiskTemplateVersions($queryParameters), $fetch);
    }

    /**
     * Return details for a specific disk template version
     * ## Scopes
     * - `disk_templates`
     * - `disk_templates:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $disk_template_version[id] The disk template version to return. All 'disk_template_version[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskTemplateVersionsDiskTemplateVersionGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDiskTemplateVersionBadRequestException
     * @throws Exception\GetDiskTemplateVersionForbiddenException
     * @throws Exception\GetDiskTemplateVersionNotFoundException
     * @throws Exception\GetDiskTemplateVersionTooManyRequestsException
     * @throws Exception\GetDiskTemplateVersionServiceUnavailableException
     */
    public function getDiskTemplateVersion(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDiskTemplateVersion($queryParameters), $fetch);
    }

    /**
     * Return details provided by this template's specification
     * ## Scopes
     * - `disk_templates`
     * - `disk_templates:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $disk_template_version[id] The disk template version to return. All 'disk_template_version[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskTemplateVersionsDiskTemplateVersionSpecGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDiskTemplateVersionSpecBadRequestException
     * @throws Exception\GetDiskTemplateVersionSpecForbiddenException
     * @throws Exception\GetDiskTemplateVersionSpecNotFoundException
     * @throws Exception\GetDiskTemplateVersionSpecTooManyRequestsException
     * @throws Exception\GetDiskTemplateVersionSpecServiceUnavailableException
     */
    public function getDiskTemplateVersionSpec(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDiskTemplateVersionSpec($queryParameters), $fetch);
    }

    /**
     * Return a list of all disk templates owned by an organization
     * ## Scopes
     * - `disk_templates`
     * - `disk_templates:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to find disk templates for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to find disk templates for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var bool   $include_universal Whether or not to include universal templates
     * @var string $operating_system[id] An operating system to use to filter disk templates. All 'operating_system[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDiskTemplatesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationDiskTemplatesBadRequestException
     * @throws Exception\GetOrganizationDiskTemplatesForbiddenException
     * @throws Exception\GetOrganizationDiskTemplatesNotFoundException
     * @throws Exception\GetOrganizationDiskTemplatesTooManyRequestsException
     * @throws Exception\GetOrganizationDiskTemplatesServiceUnavailableException
     */
    public function getOrganizationDiskTemplates(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationDiskTemplates($queryParameters), $fetch);
    }

    /**
     * Return details for a specific disk template
     * ## Scopes
     * - `disk_templates`
     * - `disk_templates:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $disk_template[id] The disk template to return. All 'disk_template[]' params are mutually exclusive, only one can be provided.
     * @var string $disk_template[permalink] The disk template to return. All 'disk_template[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DiskTemplatesDiskTemplateGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDiskTemplateBadRequestException
     * @throws Exception\GetDiskTemplateForbiddenException
     * @throws Exception\GetDiskTemplateNotFoundException
     * @throws Exception\GetDiskTemplateTooManyRequestsException
     * @throws Exception\GetDiskTemplateServiceUnavailableException
     */
    public function getDiskTemplate(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDiskTemplate($queryParameters), $fetch);
    }

    /**
     * Return a list of all disks owned by an organization
     * ## Scopes
     * - `disks`
     * - `disks:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to find disks for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to find disks for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDisksGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationDisksBadRequestException
     * @throws Exception\GetOrganizationDisksForbiddenException
     * @throws Exception\GetOrganizationDisksNotFoundException
     * @throws Exception\GetOrganizationDisksTooManyRequestsException
     * @throws Exception\GetOrganizationDisksServiceUnavailableException
     */
    public function getOrganizationDisks(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationDisks($queryParameters), $fetch);
    }

    /**
     * Create a new disk for a given organization.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationDisksPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationDisksBadRequestException
     * @throws Exception\PostOrganizationDisksForbiddenException
     * @throws Exception\PostOrganizationDisksNotFoundException
     * @throws Exception\PostOrganizationDisksNotAcceptableException
     * @throws Exception\PostOrganizationDisksUnprocessableEntityException
     * @throws Exception\PostOrganizationDisksTooManyRequestsException
     * @throws Exception\PostOrganizationDisksServiceUnavailableException
     */
    public function postOrganizationDisks(?Model\OrganizationsOrganizationDisksPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationDisks($requestBody), $fetch);
    }

    /**
     * Deletes a disk and moves it to the trash
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteDiskBadRequestException
     * @throws Exception\DeleteDiskForbiddenException
     * @throws Exception\DeleteDiskNotFoundException
     * @throws Exception\DeleteDiskNotAcceptableException
     * @throws Exception\DeleteDiskUnprocessableEntityException
     * @throws Exception\DeleteDiskTooManyRequestsException
     * @throws Exception\DeleteDiskServiceUnavailableException
     */
    public function deleteDisk(?Model\DisksDiskDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteDisk($requestBody), $fetch);
    }

    /**
     * Return details for a specific disk
     * ## Scopes
     * - `disks`
     * - `disks:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $disk[id] The disk to return. All 'disk[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDiskBadRequestException
     * @throws Exception\GetDiskForbiddenException
     * @throws Exception\GetDiskNotFoundException
     * @throws Exception\GetDiskNotAcceptableException
     * @throws Exception\GetDiskTooManyRequestsException
     * @throws Exception\GetDiskServiceUnavailableException
     */
    public function getDisk(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDisk($queryParameters), $fetch);
    }

    /**
     * Update a disk for a given organization.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchDiskBadRequestException
     * @throws Exception\PatchDiskForbiddenException
     * @throws Exception\PatchDiskNotFoundException
     * @throws Exception\PatchDiskNotAcceptableException
     * @throws Exception\PatchDiskUnprocessableEntityException
     * @throws Exception\PatchDiskTooManyRequestsException
     * @throws Exception\PatchDiskServiceUnavailableException
     */
    public function patchDisk(?Model\DisksDiskPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchDisk($requestBody), $fetch);
    }

    /**
     * Assign a disk to a virtual machine.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskAssignPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostDiskAssignBadRequestException
     * @throws Exception\PostDiskAssignForbiddenException
     * @throws Exception\PostDiskAssignNotFoundException
     * @throws Exception\PostDiskAssignNotAcceptableException
     * @throws Exception\PostDiskAssignUnprocessableEntityException
     * @throws Exception\PostDiskAssignTooManyRequestsException
     * @throws Exception\PostDiskAssignServiceUnavailableException
     */
    public function postDiskAssign(?Model\DisksDiskAssignPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostDiskAssign($requestBody), $fetch);
    }

    /**
     * Unassign a disk from a virtual machine.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskUnassignPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostDiskUnassignBadRequestException
     * @throws Exception\PostDiskUnassignForbiddenException
     * @throws Exception\PostDiskUnassignNotFoundException
     * @throws Exception\PostDiskUnassignNotAcceptableException
     * @throws Exception\PostDiskUnassignUnprocessableEntityException
     * @throws Exception\PostDiskUnassignTooManyRequestsException
     * @throws Exception\PostDiskUnassignServiceUnavailableException
     */
    public function postDiskUnassign(?Model\DisksDiskUnassignPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostDiskUnassign($requestBody), $fetch);
    }

    /**
     * Attach a disk to its virtual machine.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskAttachPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostDiskAttachBadRequestException
     * @throws Exception\PostDiskAttachForbiddenException
     * @throws Exception\PostDiskAttachNotFoundException
     * @throws Exception\PostDiskAttachNotAcceptableException
     * @throws Exception\PostDiskAttachUnprocessableEntityException
     * @throws Exception\PostDiskAttachTooManyRequestsException
     * @throws Exception\PostDiskAttachServiceUnavailableException
     */
    public function postDiskAttach(?Model\DisksDiskAttachPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostDiskAttach($requestBody), $fetch);
    }

    /**
     * Detach a disk from its virtual machine.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskDetachPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostDiskDetachBadRequestException
     * @throws Exception\PostDiskDetachForbiddenException
     * @throws Exception\PostDiskDetachNotFoundException
     * @throws Exception\PostDiskDetachNotAcceptableException
     * @throws Exception\PostDiskDetachUnprocessableEntityException
     * @throws Exception\PostDiskDetachTooManyRequestsException
     * @throws Exception\PostDiskDetachServiceUnavailableException
     */
    public function postDiskDetach(?Model\DisksDiskDetachPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostDiskDetach($requestBody), $fetch);
    }

    /**
     * Resize a disk.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskResizePutResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PutDiskResizeBadRequestException
     * @throws Exception\PutDiskResizeForbiddenException
     * @throws Exception\PutDiskResizeNotFoundException
     * @throws Exception\PutDiskResizeNotAcceptableException
     * @throws Exception\PutDiskResizeUnprocessableEntityException
     * @throws Exception\PutDiskResizeTooManyRequestsException
     * @throws Exception\PutDiskResizeServiceUnavailableException
     */
    public function putDiskResize(?Model\DisksDiskResizePutBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PutDiskResize($requestBody), $fetch);
    }

    /**
     * Change disk IO profile.
     * ## Scopes
     * - `disks`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DisksDiskIoProfilePutResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PutDiskIoProfileBadRequestException
     * @throws Exception\PutDiskIoProfileForbiddenException
     * @throws Exception\PutDiskIoProfileNotFoundException
     * @throws Exception\PutDiskIoProfileNotAcceptableException
     * @throws Exception\PutDiskIoProfileTooManyRequestsException
     * @throws Exception\PutDiskIoProfileServiceUnavailableException
     */
    public function putDiskIoProfile(?Model\DisksDiskIoProfilePutBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PutDiskIoProfile($requestBody), $fetch);
    }

    /**
     * Return a list of all disks for a given virtual machine
     * ## Scopes
     * - `disks`
     * - `disks:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine[id] The virtual machine to find disks for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var string $virtual_machine[fqdn] The virtual machine to find disks for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineDisksGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineDisksBadRequestException
     * @throws Exception\GetVirtualMachineDisksForbiddenException
     * @throws Exception\GetVirtualMachineDisksNotFoundException
     * @throws Exception\GetVirtualMachineDisksNotAcceptableException
     * @throws Exception\GetVirtualMachineDisksTooManyRequestsException
     * @throws Exception\GetVirtualMachineDisksServiceUnavailableException
     */
    public function getVirtualMachineDisks(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachineDisks($queryParameters), $fetch);
    }

    /**
     * Returns a list of all file storage volumes for a given organization
     * ## Scopes
     * - `file_storage_volumes`
     * - `file_storage_volumes:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to return all file storage volumes for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to return all file storage volumes for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationFileStorageVolumesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationFileStorageVolumesBadRequestException
     * @throws Exception\GetOrganizationFileStorageVolumesForbiddenException
     * @throws Exception\GetOrganizationFileStorageVolumesNotFoundException
     * @throws Exception\GetOrganizationFileStorageVolumesTooManyRequestsException
     * @throws Exception\GetOrganizationFileStorageVolumesServiceUnavailableException
     */
    public function getOrganizationFileStorageVolumes(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationFileStorageVolumes($queryParameters), $fetch);
    }

    /**
     * Create a new file storage volume for a given organization.
     * ## Scopes
     * - `file_storage_volumes`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationFileStorageVolumesPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationFileStorageVolumesBadRequestException
     * @throws Exception\PostOrganizationFileStorageVolumesForbiddenException
     * @throws Exception\PostOrganizationFileStorageVolumesNotFoundException
     * @throws Exception\PostOrganizationFileStorageVolumesUnprocessableEntityException
     * @throws Exception\PostOrganizationFileStorageVolumesTooManyRequestsException
     * @throws Exception\PostOrganizationFileStorageVolumesServiceUnavailableException
     */
    public function postOrganizationFileStorageVolumes(?Model\OrganizationsOrganizationFileStorageVolumesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationFileStorageVolumes($requestBody), $fetch);
    }

    /**
     * Delete a file storage volume.
     * ## Scopes
     * - `file_storage_volumes`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\FileStorageVolumesFileStorageVolumeDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteFileStorageVolumeBadRequestException
     * @throws Exception\DeleteFileStorageVolumeForbiddenException
     * @throws Exception\DeleteFileStorageVolumeNotFoundException
     * @throws Exception\DeleteFileStorageVolumeNotAcceptableException
     * @throws Exception\DeleteFileStorageVolumeUnprocessableEntityException
     * @throws Exception\DeleteFileStorageVolumeTooManyRequestsException
     * @throws Exception\DeleteFileStorageVolumeServiceUnavailableException
     */
    public function deleteFileStorageVolume(?Model\FileStorageVolumesFileStorageVolumeDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteFileStorageVolume($requestBody), $fetch);
    }

    /**
     * Returns details for a file storage volume.
     * ## Scopes
     * - `file_storage_volumes`
     * - `file_storage_volumes:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $file_storage_volume[id] The file storage volume to return. All 'file_storage_volume[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\FileStorageVolumesFileStorageVolumeGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetFileStorageVolumeBadRequestException
     * @throws Exception\GetFileStorageVolumeForbiddenException
     * @throws Exception\GetFileStorageVolumeNotFoundException
     * @throws Exception\GetFileStorageVolumeNotAcceptableException
     * @throws Exception\GetFileStorageVolumeTooManyRequestsException
     * @throws Exception\GetFileStorageVolumeServiceUnavailableException
     */
    public function getFileStorageVolume(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetFileStorageVolume($queryParameters), $fetch);
    }

    /**
     * Update a file storage volume with new properties.
     * ## Scopes
     * - `file_storage_volumes`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\FileStorageVolumesFileStorageVolumePatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchFileStorageVolumeBadRequestException
     * @throws Exception\PatchFileStorageVolumeForbiddenException
     * @throws Exception\PatchFileStorageVolumeNotFoundException
     * @throws Exception\PatchFileStorageVolumeNotAcceptableException
     * @throws Exception\PatchFileStorageVolumeUnprocessableEntityException
     * @throws Exception\PatchFileStorageVolumeTooManyRequestsException
     * @throws Exception\PatchFileStorageVolumeServiceUnavailableException
     */
    public function patchFileStorageVolume(?Model\FileStorageVolumesFileStorageVolumePatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchFileStorageVolume($requestBody), $fetch);
    }

    /**
     * Provides a full list of all GPU types.
     *
     * @param array $queryParameters {
     *
     * @var int $page
     * @var int $per_page
     *          }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GpuTypesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetGpuTypesBadRequestException
     * @throws Exception\GetGpuTypesForbiddenException
     * @throws Exception\GetGpuTypesTooManyRequestsException
     * @throws Exception\GetGpuTypesServiceUnavailableException
     */
    public function getGpuTypes(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGpuTypes($queryParameters), $fetch);
    }

    /**
     * Provide details for a specific GPU type.
     *
     * @param array $queryParameters {
     *
     * @var string $gpu_type[id] All 'gpu_type[]' params are mutually exclusive, only one can be provided
     * @var string $gpu_type[permalink] All 'gpu_type[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\GpuTypesGpuTypeGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetGpuTypeBadRequestException
     * @throws Exception\GetGpuTypeForbiddenException
     * @throws Exception\GetGpuTypeNotFoundException
     * @throws Exception\GetGpuTypeTooManyRequestsException
     * @throws Exception\GetGpuTypeServiceUnavailableException
     */
    public function getGpuType(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetGpuType($queryParameters), $fetch);
    }

    /**
     * Provides a list of all GPU types available in a given data center.
     *
     * @param array $queryParameters {
     *
     * @var string $data_center[id] The data center to list GPU types for. All 'data_center[]' params are mutually exclusive, only one can be provided.
     * @var string $data_center[permalink] The data center to list GPU types for. All 'data_center[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\DataCentersDataCenterGpuTypesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetDataCenterGpuTypesBadRequestException
     * @throws Exception\GetDataCenterGpuTypesForbiddenException
     * @throws Exception\GetDataCenterGpuTypesNotFoundException
     * @throws Exception\GetDataCenterGpuTypesTooManyRequestsException
     * @throws Exception\GetDataCenterGpuTypesServiceUnavailableException
     */
    public function getDataCenterGpuTypes(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetDataCenterGpuTypes($queryParameters), $fetch);
    }

    /**
     * Returns a list of all IP addresses belonging to an organization
     * ## Scopes
     * - `ip_addresses`
     * - `ip_addresses:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to use when looking up IP addresses. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to use when looking up IP addresses. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var bool   $allocated If true, only return allocated IP addresss. If false, only return unallocated IP addresses.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationIpAddressesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationIpAddressesBadRequestException
     * @throws Exception\GetOrganizationIpAddressesForbiddenException
     * @throws Exception\GetOrganizationIpAddressesNotFoundException
     * @throws Exception\GetOrganizationIpAddressesTooManyRequestsException
     * @throws Exception\GetOrganizationIpAddressesServiceUnavailableException
     */
    public function getOrganizationIpAddresses(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationIpAddresses($queryParameters), $fetch);
    }

    /**
     * Creates a new IP address on this organization
     * ## Scopes
     * - `ip_addresses`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationIpAddressesPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationIpAddressesBadRequestException
     * @throws Exception\PostOrganizationIpAddressesForbiddenException
     * @throws Exception\PostOrganizationIpAddressesNotFoundException
     * @throws Exception\PostOrganizationIpAddressesUnprocessableEntityException
     * @throws Exception\PostOrganizationIpAddressesTooManyRequestsException
     * @throws Exception\PostOrganizationIpAddressesServiceUnavailableException
     */
    public function postOrganizationIpAddresses(?Model\OrganizationsOrganizationIpAddressesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationIpAddresses($requestBody), $fetch);
    }

    /**
     * Release an IP address from its organization
     * ## Scopes
     * - `ip_addresses`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\IpAddressesIpAddressDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteIpAddressBadRequestException
     * @throws Exception\DeleteIpAddressForbiddenException
     * @throws Exception\DeleteIpAddressNotFoundException
     * @throws Exception\DeleteIpAddressConflictException
     * @throws Exception\DeleteIpAddressTooManyRequestsException
     * @throws Exception\DeleteIpAddressServiceUnavailableException
     */
    public function deleteIpAddress(?Model\IpAddressesIpAddressDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteIpAddress($requestBody), $fetch);
    }

    /**
     * Returns information about a specific IP address
     * ## Scopes
     * - `ip_addresses`
     * - `ip_addresses:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $ip_address[id] The IP address to find. All 'ip_address[]' params are mutually exclusive, only one can be provided.
     * @var string $ip_address[address] The IP address to find. All 'ip_address[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\IpAddressesIpAddressGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetIpAddressBadRequestException
     * @throws Exception\GetIpAddressForbiddenException
     * @throws Exception\GetIpAddressNotFoundException
     * @throws Exception\GetIpAddressTooManyRequestsException
     * @throws Exception\GetIpAddressServiceUnavailableException
     */
    public function getIpAddress(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetIpAddress($queryParameters), $fetch);
    }

    /**
     * Updates the details on an IP address
     * ## Scopes
     * - `ip_addresses`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\IpAddressesIpAddressPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchIpAddressBadRequestException
     * @throws Exception\PatchIpAddressForbiddenException
     * @throws Exception\PatchIpAddressNotFoundException
     * @throws Exception\PatchIpAddressUnprocessableEntityException
     * @throws Exception\PatchIpAddressTooManyRequestsException
     * @throws Exception\PatchIpAddressServiceUnavailableException
     */
    public function patchIpAddress(?Model\IpAddressesIpAddressPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchIpAddress($requestBody), $fetch);
    }

    /**
     * Unallocate an IP address from its resource
     * ## Scopes
     * - `ip_addresses`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\IpAddressesIpAddressUnallocatePostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostIpAddressUnallocateBadRequestException
     * @throws Exception\PostIpAddressUnallocateForbiddenException
     * @throws Exception\PostIpAddressUnallocateNotFoundException
     * @throws Exception\PostIpAddressUnallocateConflictException
     * @throws Exception\PostIpAddressUnallocateUnprocessableEntityException
     * @throws Exception\PostIpAddressUnallocateTooManyRequestsException
     * @throws Exception\PostIpAddressUnallocateServiceUnavailableException
     */
    public function postIpAddressUnallocate(?Model\IpAddressesIpAddressUnallocatePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostIpAddressUnallocate($requestBody), $fetch);
    }

    /**
     * Returns a list of all load balancers for a given organization
     * ## Scopes
     * - `load_balancers`
     * - `load_balancers:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to return all load balancers for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to return all load balancers for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationLoadBalancersGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationLoadBalancersBadRequestException
     * @throws Exception\GetOrganizationLoadBalancersForbiddenException
     * @throws Exception\GetOrganizationLoadBalancersNotFoundException
     * @throws Exception\GetOrganizationLoadBalancersTooManyRequestsException
     * @throws Exception\GetOrganizationLoadBalancersServiceUnavailableException
     */
    public function getOrganizationLoadBalancers(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationLoadBalancers($queryParameters), $fetch);
    }

    /**
     * Create a new load balancer for a given organization
     * ## Scopes
     * - `load_balancers`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationLoadBalancersPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationLoadBalancersBadRequestException
     * @throws Exception\PostOrganizationLoadBalancersForbiddenException
     * @throws Exception\PostOrganizationLoadBalancersNotFoundException
     * @throws Exception\PostOrganizationLoadBalancersUnprocessableEntityException
     * @throws Exception\PostOrganizationLoadBalancersTooManyRequestsException
     * @throws Exception\PostOrganizationLoadBalancersServiceUnavailableException
     */
    public function postOrganizationLoadBalancers(?Model\OrganizationsOrganizationLoadBalancersPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationLoadBalancers($requestBody), $fetch);
    }

    /**
     * Delete a load balancer
     * ## Scopes
     * - `load_balancers`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersLoadBalancerDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteLoadBalancerBadRequestException
     * @throws Exception\DeleteLoadBalancerForbiddenException
     * @throws Exception\DeleteLoadBalancerNotFoundException
     * @throws Exception\DeleteLoadBalancerUnprocessableEntityException
     * @throws Exception\DeleteLoadBalancerTooManyRequestsException
     * @throws Exception\DeleteLoadBalancerServiceUnavailableException
     */
    public function deleteLoadBalancer(?Model\LoadBalancersLoadBalancerDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteLoadBalancer($requestBody), $fetch);
    }

    /**
     * Returns details about a load balancer
     * ## Scopes
     * - `load_balancers`
     * - `load_balancers:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $load_balancer[id] The load balancer to return the details for. All 'load_balancer[]' params are mutually exclusive, only one can be provided.
     * @var string $load_balancer[api_reference] The load balancer to return the details for. All 'load_balancer[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersLoadBalancerGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetLoadBalancerBadRequestException
     * @throws Exception\GetLoadBalancerForbiddenException
     * @throws Exception\GetLoadBalancerNotFoundException
     * @throws Exception\GetLoadBalancerTooManyRequestsException
     * @throws Exception\GetLoadBalancerServiceUnavailableException
     */
    public function getLoadBalancer(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLoadBalancer($queryParameters), $fetch);
    }

    /**
     * Updates a load balancer with new properties
     * ## Scopes
     * - `load_balancers`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersLoadBalancerPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchLoadBalancerBadRequestException
     * @throws Exception\PatchLoadBalancerForbiddenException
     * @throws Exception\PatchLoadBalancerNotFoundException
     * @throws Exception\PatchLoadBalancerUnprocessableEntityException
     * @throws Exception\PatchLoadBalancerTooManyRequestsException
     * @throws Exception\PatchLoadBalancerServiceUnavailableException
     */
    public function patchLoadBalancer(?Model\LoadBalancersLoadBalancerPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchLoadBalancer($requestBody), $fetch);
    }

    /**
     * Returns a list of all rules for a given load balancer
     * ## Scopes
     * - `load_balancers`
     * - `load_balancers:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $load_balancer[id] The load balancer to return all load rules for. All 'load_balancer[]' params are mutually exclusive, only one can be provided.
     * @var string $load_balancer[api_reference] The load balancer to return all load rules for. All 'load_balancer[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersLoadBalancerRulesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetLoadBalancerRulesBadRequestException
     * @throws Exception\GetLoadBalancerRulesForbiddenException
     * @throws Exception\GetLoadBalancerRulesNotFoundException
     * @throws Exception\GetLoadBalancerRulesTooManyRequestsException
     * @throws Exception\GetLoadBalancerRulesServiceUnavailableException
     */
    public function getLoadBalancerRules(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLoadBalancerRules($queryParameters), $fetch);
    }

    /**
     * Create a new load balancer rule
     * ## Scopes
     * - `load_balancers`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersLoadBalancerRulesPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostLoadBalancerRulesBadRequestException
     * @throws Exception\PostLoadBalancerRulesForbiddenException
     * @throws Exception\PostLoadBalancerRulesNotFoundException
     * @throws Exception\PostLoadBalancerRulesUnprocessableEntityException
     * @throws Exception\PostLoadBalancerRulesTooManyRequestsException
     * @throws Exception\PostLoadBalancerRulesServiceUnavailableException
     */
    public function postLoadBalancerRules(?Model\LoadBalancersLoadBalancerRulesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostLoadBalancerRules($requestBody), $fetch);
    }

    /**
     * Delete a load balancer rule
     * ## Scopes
     * - `load_balancers`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersRulesLoadBalancerRuleDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteLoadBalancersRulesLoadBalancerRuleBadRequestException
     * @throws Exception\DeleteLoadBalancersRulesLoadBalancerRuleForbiddenException
     * @throws Exception\DeleteLoadBalancersRulesLoadBalancerRuleNotFoundException
     * @throws Exception\DeleteLoadBalancersRulesLoadBalancerRuleUnprocessableEntityException
     * @throws Exception\DeleteLoadBalancersRulesLoadBalancerRuleTooManyRequestsException
     * @throws Exception\DeleteLoadBalancersRulesLoadBalancerRuleServiceUnavailableException
     */
    public function deleteLoadBalancersRulesLoadBalancerRule(?Model\LoadBalancersRulesLoadBalancerRuleDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteLoadBalancersRulesLoadBalancerRule($requestBody), $fetch);
    }

    /**
     * Returns details about a load balancer rule
     * ## Scopes
     * - `load_balancers`
     * - `load_balancers:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $load_balancer_rule[id] The load balancer rule to return the details for. All 'load_balancer_rule[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersRulesLoadBalancerRuleGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetLoadBalancersRulesLoadBalancerRuleBadRequestException
     * @throws Exception\GetLoadBalancersRulesLoadBalancerRuleForbiddenException
     * @throws Exception\GetLoadBalancersRulesLoadBalancerRuleNotFoundException
     * @throws Exception\GetLoadBalancersRulesLoadBalancerRuleTooManyRequestsException
     * @throws Exception\GetLoadBalancersRulesLoadBalancerRuleServiceUnavailableException
     */
    public function getLoadBalancersRulesLoadBalancerRule(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetLoadBalancersRulesLoadBalancerRule($queryParameters), $fetch);
    }

    /**
     * Updates a load balancer rule with new properties
     * ## Scopes
     * - `load_balancers`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\LoadBalancersRulesLoadBalancerRulePatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchLoadBalancersRulesLoadBalancerRuleBadRequestException
     * @throws Exception\PatchLoadBalancersRulesLoadBalancerRuleForbiddenException
     * @throws Exception\PatchLoadBalancersRulesLoadBalancerRuleNotFoundException
     * @throws Exception\PatchLoadBalancersRulesLoadBalancerRuleUnprocessableEntityException
     * @throws Exception\PatchLoadBalancersRulesLoadBalancerRuleTooManyRequestsException
     * @throws Exception\PatchLoadBalancersRulesLoadBalancerRuleServiceUnavailableException
     */
    public function patchLoadBalancersRulesLoadBalancerRule(?Model\LoadBalancersRulesLoadBalancerRulePatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchLoadBalancersRulesLoadBalancerRule($requestBody), $fetch);
    }

    /**
     * Returns a list of all network speed profiles available to an organization.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to use when looking up network speed profiles. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to use when looking up network speed profiles. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationNetworkSpeedProfilesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationNetworkSpeedProfilesBadRequestException
     * @throws Exception\GetOrganizationNetworkSpeedProfilesForbiddenException
     * @throws Exception\GetOrganizationNetworkSpeedProfilesNotFoundException
     * @throws Exception\GetOrganizationNetworkSpeedProfilesTooManyRequestsException
     * @throws Exception\GetOrganizationNetworkSpeedProfilesServiceUnavailableException
     */
    public function getOrganizationNetworkSpeedProfiles(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationNetworkSpeedProfiles($queryParameters), $fetch);
    }

    /**
     * Returns a list of all networks available for an organization.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationAvailableNetworksGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationAvailableNetworksBadRequestException
     * @throws Exception\GetOrganizationAvailableNetworksForbiddenException
     * @throws Exception\GetOrganizationAvailableNetworksNotFoundException
     * @throws Exception\GetOrganizationAvailableNetworksTooManyRequestsException
     * @throws Exception\GetOrganizationAvailableNetworksServiceUnavailableException
     */
    public function getOrganizationAvailableNetworks(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationAvailableNetworks($queryParameters), $fetch);
    }

    /**
     * Returns details for a specific network.
     *
     * @param array $queryParameters {
     *
     * @var string $network[id] The network to return. All 'network[]' params are mutually exclusive, only one can be provided.
     * @var string $network[permalink] The network to return. All 'network[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\NetworksNetworkGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetNetworkBadRequestException
     * @throws Exception\GetNetworkForbiddenException
     * @throws Exception\GetNetworkNotFoundException
     * @throws Exception\GetNetworkTooManyRequestsException
     * @throws Exception\GetNetworkServiceUnavailableException
     */
    public function getNetwork(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetNetwork($queryParameters), $fetch);
    }

    /**
     * Return a list of all operating systems.
     *
     * @param array $queryParameters {
     *
     * @var int $page
     * @var int $per_page
     *          }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OperatingSystemsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOperatingSystemsBadRequestException
     * @throws Exception\GetOperatingSystemsForbiddenException
     * @throws Exception\GetOperatingSystemsTooManyRequestsException
     * @throws Exception\GetOperatingSystemsServiceUnavailableException
     */
    public function getOperatingSystems(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperatingSystems($queryParameters), $fetch);
    }

    /**
     * Return details for a specific operating system.
     *
     * @param array $queryParameters {
     *
     * @var string $operating_system[id] The operating system to return. All 'operating_system[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OperatingSystemsOperatingSystemGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOperatingSystemBadRequestException
     * @throws Exception\GetOperatingSystemForbiddenException
     * @throws Exception\GetOperatingSystemNotFoundException
     * @throws Exception\GetOperatingSystemTooManyRequestsException
     * @throws Exception\GetOperatingSystemServiceUnavailableException
     */
    public function getOperatingSystem(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOperatingSystem($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationsBadRequestException
     * @throws Exception\GetOrganizationsForbiddenException
     * @throws Exception\GetOrganizationsTooManyRequestsException
     * @throws Exception\GetOrganizationsServiceUnavailableException
     */
    public function getOrganizations(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizations(), $fetch);
    }

    /**
     * Returns information about a specific organization
     * ## Scopes
     * - `organizations:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationBadRequestException
     * @throws Exception\GetOrganizationForbiddenException
     * @throws Exception\GetOrganizationNotFoundException
     * @throws Exception\GetOrganizationTooManyRequestsException
     * @throws Exception\GetOrganizationServiceUnavailableException
     */
    public function getOrganization(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganization($queryParameters), $fetch);
    }

    /**
     * Returns the computed policy limits for a organization
     * ## Scopes
     * - `organizations:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationPolicyGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationPolicyBadRequestException
     * @throws Exception\GetOrganizationPolicyForbiddenException
     * @throws Exception\GetOrganizationPolicyNotFoundException
     * @throws Exception\GetOrganizationPolicyTooManyRequestsException
     * @throws Exception\GetOrganizationPolicyServiceUnavailableException
     */
    public function getOrganizationPolicy(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationPolicy($queryParameters), $fetch);
    }

    /**
     * Returns the computed policy limits for a organization
     * ## Scopes
     * - `organizations:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationPolicyLimitsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationPolicyLimitsBadRequestException
     * @throws Exception\GetOrganizationPolicyLimitsForbiddenException
     * @throws Exception\GetOrganizationPolicyLimitsNotFoundException
     * @throws Exception\GetOrganizationPolicyLimitsTooManyRequestsException
     * @throws Exception\GetOrganizationPolicyLimitsServiceUnavailableException
     */
    public function getOrganizationPolicyLimits(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationPolicyLimits($queryParameters), $fetch);
    }

    /**
     * Returns the active prices for an organization
     * ## Scopes
     * - `organizations:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationPricesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationPricesBadRequestException
     * @throws Exception\GetOrganizationPricesForbiddenException
     * @throws Exception\GetOrganizationPricesNotFoundException
     * @throws Exception\GetOrganizationPricesTooManyRequestsException
     * @throws Exception\GetOrganizationPricesServiceUnavailableException
     */
    public function getOrganizationPrices(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationPrices($queryParameters), $fetch);
    }

    /**
     * This will return a simple list of users with any access to this organization. This
     * endpoint is available to all users with access to the organization therefore allows
     * them to see a small amount of information about their peers. This is useful when
     * combined with other API actions that require the ID of a fellow user (such as when
     * determining which users to assign a virtual machine).
     *
     * ## Scopes
     * - `organizations:read`
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationUsersWithAccessGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationUsersWithAccessBadRequestException
     * @throws Exception\GetOrganizationUsersWithAccessForbiddenException
     * @throws Exception\GetOrganizationUsersWithAccessNotFoundException
     * @throws Exception\GetOrganizationUsersWithAccessTooManyRequestsException
     * @throws Exception\GetOrganizationUsersWithAccessServiceUnavailableException
     */
    public function getOrganizationUsersWithAccess(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationUsersWithAccess($queryParameters), $fetch);
    }

    /**
     * List all managed organizations owned by the given organization
     * ## Scopes
     * - `managed_organizations`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationManagedGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationManagedBadRequestException
     * @throws Exception\GetOrganizationManagedForbiddenException
     * @throws Exception\GetOrganizationManagedNotFoundException
     * @throws Exception\GetOrganizationManagedTooManyRequestsException
     * @throws Exception\GetOrganizationManagedServiceUnavailableException
     */
    public function getOrganizationManaged(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationManaged($queryParameters), $fetch);
    }

    /**
     * Create a new managed organization within an existing organization
     * ## Scopes
     * - `managed_organizations`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationManagedPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationManagedBadRequestException
     * @throws Exception\PostOrganizationManagedForbiddenException
     * @throws Exception\PostOrganizationManagedNotFoundException
     * @throws Exception\PostOrganizationManagedUnprocessableEntityException
     * @throws Exception\PostOrganizationManagedTooManyRequestsException
     * @throws Exception\PostOrganizationManagedServiceUnavailableException
     */
    public function postOrganizationManaged(?Model\OrganizationsOrganizationManagedPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationManaged($requestBody), $fetch);
    }

    /**
     * Returns a list of all SSH keys for an organization.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to list SSH keys for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to list SSH keys for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationSshKeysGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationSshKeysBadRequestException
     * @throws Exception\GetOrganizationSshKeysForbiddenException
     * @throws Exception\GetOrganizationSshKeysNotFoundException
     * @throws Exception\GetOrganizationSshKeysTooManyRequestsException
     * @throws Exception\GetOrganizationSshKeysServiceUnavailableException
     */
    public function getOrganizationSshKeys(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationSshKeys($queryParameters), $fetch);
    }

    /**
     * Add an SSH key to an organization.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationSshKeysPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationSshKeysBadRequestException
     * @throws Exception\PostOrganizationSshKeysForbiddenException
     * @throws Exception\PostOrganizationSshKeysNotFoundException
     * @throws Exception\PostOrganizationSshKeysUnprocessableEntityException
     * @throws Exception\PostOrganizationSshKeysTooManyRequestsException
     * @throws Exception\PostOrganizationSshKeysServiceUnavailableException
     */
    public function postOrganizationSshKeys(?Model\OrganizationsOrganizationSshKeysPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationSshKeys($requestBody), $fetch);
    }

    /**
     * Delete an SSH key.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SshKeysSshKeyDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteSshKeyBadRequestException
     * @throws Exception\DeleteSshKeyForbiddenException
     * @throws Exception\DeleteSshKeyNotFoundException
     * @throws Exception\DeleteSshKeyConflictException
     * @throws Exception\DeleteSshKeyTooManyRequestsException
     * @throws Exception\DeleteSshKeyServiceUnavailableException
     */
    public function deleteSshKey(?Model\SshKeysSshKeyDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteSshKey($requestBody), $fetch);
    }

    /**
     * Returns a list of all security groups for a given organization
     * ## Scopes
     * - `security_groups`
     * - `security_groups:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to return all security groups for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to return all security groups for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationSecurityGroupsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationSecurityGroupsBadRequestException
     * @throws Exception\GetOrganizationSecurityGroupsForbiddenException
     * @throws Exception\GetOrganizationSecurityGroupsNotFoundException
     * @throws Exception\GetOrganizationSecurityGroupsTooManyRequestsException
     * @throws Exception\GetOrganizationSecurityGroupsServiceUnavailableException
     */
    public function getOrganizationSecurityGroups(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationSecurityGroups($queryParameters), $fetch);
    }

    /**
     * Create a new security group for a given organization
     * ## Scopes
     * - `security_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationSecurityGroupsPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationSecurityGroupsBadRequestException
     * @throws Exception\PostOrganizationSecurityGroupsForbiddenException
     * @throws Exception\PostOrganizationSecurityGroupsNotFoundException
     * @throws Exception\PostOrganizationSecurityGroupsUnprocessableEntityException
     * @throws Exception\PostOrganizationSecurityGroupsTooManyRequestsException
     * @throws Exception\PostOrganizationSecurityGroupsServiceUnavailableException
     */
    public function postOrganizationSecurityGroups(?Model\OrganizationsOrganizationSecurityGroupsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationSecurityGroups($requestBody), $fetch);
    }

    /**
     * Delete a security group
     * ## Scopes
     * - `security_group`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsSecurityGroupDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteSecurityGroupBadRequestException
     * @throws Exception\DeleteSecurityGroupForbiddenException
     * @throws Exception\DeleteSecurityGroupNotFoundException
     * @throws Exception\DeleteSecurityGroupConflictException
     * @throws Exception\DeleteSecurityGroupUnprocessableEntityException
     * @throws Exception\DeleteSecurityGroupTooManyRequestsException
     * @throws Exception\DeleteSecurityGroupServiceUnavailableException
     */
    public function deleteSecurityGroup(?Model\SecurityGroupsSecurityGroupDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteSecurityGroup($requestBody), $fetch);
    }

    /**
     * Returns details about a security group
     * ## Scopes
     * - `security_groups`
     * - `security_groups:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $security_group[id] The security group to return the details for. All 'security_group[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsSecurityGroupGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetSecurityGroupBadRequestException
     * @throws Exception\GetSecurityGroupForbiddenException
     * @throws Exception\GetSecurityGroupNotFoundException
     * @throws Exception\GetSecurityGroupTooManyRequestsException
     * @throws Exception\GetSecurityGroupServiceUnavailableException
     */
    public function getSecurityGroup(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetSecurityGroup($queryParameters), $fetch);
    }

    /**
     * Updates a security group with new properties
     * ## Scopes
     * - `security_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsSecurityGroupPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchSecurityGroupBadRequestException
     * @throws Exception\PatchSecurityGroupForbiddenException
     * @throws Exception\PatchSecurityGroupNotFoundException
     * @throws Exception\PatchSecurityGroupUnprocessableEntityException
     * @throws Exception\PatchSecurityGroupTooManyRequestsException
     * @throws Exception\PatchSecurityGroupServiceUnavailableException
     */
    public function patchSecurityGroup(?Model\SecurityGroupsSecurityGroupPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchSecurityGroup($requestBody), $fetch);
    }

    /**
     * Returns a list of all rules for a given security group
     * ## Scopes
     * - `security_groups`
     * - `security_groups:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $security_group[id] The security group to return all load rules for. All 'security_group[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsSecurityGroupRulesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetSecurityGroupRulesBadRequestException
     * @throws Exception\GetSecurityGroupRulesForbiddenException
     * @throws Exception\GetSecurityGroupRulesNotFoundException
     * @throws Exception\GetSecurityGroupRulesTooManyRequestsException
     * @throws Exception\GetSecurityGroupRulesServiceUnavailableException
     */
    public function getSecurityGroupRules(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetSecurityGroupRules($queryParameters), $fetch);
    }

    /**
     * Create a new security group rule
     * ## Scopes
     * - `security_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsSecurityGroupRulesPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostSecurityGroupRulesBadRequestException
     * @throws Exception\PostSecurityGroupRulesForbiddenException
     * @throws Exception\PostSecurityGroupRulesNotFoundException
     * @throws Exception\PostSecurityGroupRulesUnprocessableEntityException
     * @throws Exception\PostSecurityGroupRulesTooManyRequestsException
     * @throws Exception\PostSecurityGroupRulesServiceUnavailableException
     */
    public function postSecurityGroupRules(?Model\SecurityGroupsSecurityGroupRulesPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostSecurityGroupRules($requestBody), $fetch);
    }

    /**
     * Delete a security group rule
     * ## Scopes
     * - `security_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsRulesSecurityGroupRuleDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteSecurityGroupsRulesSecurityGroupRuleBadRequestException
     * @throws Exception\DeleteSecurityGroupsRulesSecurityGroupRuleForbiddenException
     * @throws Exception\DeleteSecurityGroupsRulesSecurityGroupRuleNotFoundException
     * @throws Exception\DeleteSecurityGroupsRulesSecurityGroupRuleUnprocessableEntityException
     * @throws Exception\DeleteSecurityGroupsRulesSecurityGroupRuleTooManyRequestsException
     * @throws Exception\DeleteSecurityGroupsRulesSecurityGroupRuleServiceUnavailableException
     */
    public function deleteSecurityGroupsRulesSecurityGroupRule(?Model\SecurityGroupsRulesSecurityGroupRuleDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteSecurityGroupsRulesSecurityGroupRule($requestBody), $fetch);
    }

    /**
     * Returns details about a security group rule
     * ## Scopes
     * - `security_groups`
     * - `security_groups:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $security_group_rule[id] The security group rule to return the details for. All 'security_group_rule[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsRulesSecurityGroupRuleGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetSecurityGroupsRulesSecurityGroupRuleBadRequestException
     * @throws Exception\GetSecurityGroupsRulesSecurityGroupRuleForbiddenException
     * @throws Exception\GetSecurityGroupsRulesSecurityGroupRuleNotFoundException
     * @throws Exception\GetSecurityGroupsRulesSecurityGroupRuleTooManyRequestsException
     * @throws Exception\GetSecurityGroupsRulesSecurityGroupRuleServiceUnavailableException
     */
    public function getSecurityGroupsRulesSecurityGroupRule(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetSecurityGroupsRulesSecurityGroupRule($queryParameters), $fetch);
    }

    /**
     * Updates a security group rule with new properties
     * ## Scopes
     * - `security_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\SecurityGroupsRulesSecurityGroupRulePatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchSecurityGroupsRulesSecurityGroupRuleBadRequestException
     * @throws Exception\PatchSecurityGroupsRulesSecurityGroupRuleForbiddenException
     * @throws Exception\PatchSecurityGroupsRulesSecurityGroupRuleNotFoundException
     * @throws Exception\PatchSecurityGroupsRulesSecurityGroupRuleUnprocessableEntityException
     * @throws Exception\PatchSecurityGroupsRulesSecurityGroupRuleTooManyRequestsException
     * @throws Exception\PatchSecurityGroupsRulesSecurityGroupRuleServiceUnavailableException
     */
    public function patchSecurityGroupsRulesSecurityGroupRule(?Model\SecurityGroupsRulesSecurityGroupRulePatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchSecurityGroupsRulesSecurityGroupRule($requestBody), $fetch);
    }

    /**
     * Returns a list of all tags for an organization
     * ## Scopes
     * - `tags`
     * - `tags:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to list the tags for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to list the tags for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationTagsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationTagsBadRequestException
     * @throws Exception\GetOrganizationTagsForbiddenException
     * @throws Exception\GetOrganizationTagsNotFoundException
     * @throws Exception\GetOrganizationTagsTooManyRequestsException
     * @throws Exception\GetOrganizationTagsServiceUnavailableException
     */
    public function getOrganizationTags(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationTags($queryParameters), $fetch);
    }

    /**
     * Creates a new tag with the provided properties
     * ## Scopes
     * - `tags`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationTagsPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationTagsBadRequestException
     * @throws Exception\PostOrganizationTagsForbiddenException
     * @throws Exception\PostOrganizationTagsNotFoundException
     * @throws Exception\PostOrganizationTagsUnprocessableEntityException
     * @throws Exception\PostOrganizationTagsTooManyRequestsException
     * @throws Exception\PostOrganizationTagsServiceUnavailableException
     */
    public function postOrganizationTags(?Model\OrganizationsOrganizationTagsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationTags($requestBody), $fetch);
    }

    /**
     * Deletes a tag
     * ## Scopes
     * - `tags`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\TagsTagDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteTagBadRequestException
     * @throws Exception\DeleteTagForbiddenException
     * @throws Exception\DeleteTagNotFoundException
     * @throws Exception\DeleteTagTooManyRequestsException
     * @throws Exception\DeleteTagServiceUnavailableException
     */
    public function deleteTag(?Model\TagsTagDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteTag($requestBody), $fetch);
    }

    /**
     * Returns details about a specific tag
     * ## Scopes
     * - `tags`
     * - `tags:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $tag[id] The tag to load the details for. All 'tag[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\TagsTagGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetTagBadRequestException
     * @throws Exception\GetTagForbiddenException
     * @throws Exception\GetTagNotFoundException
     * @throws Exception\GetTagTooManyRequestsException
     * @throws Exception\GetTagServiceUnavailableException
     */
    public function getTag(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetTag($queryParameters), $fetch);
    }

    /**
     * Updates a tag with the provided properties
     * ## Scopes
     * - `tags`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\TagsTagPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchTagBadRequestException
     * @throws Exception\PatchTagForbiddenException
     * @throws Exception\PatchTagNotFoundException
     * @throws Exception\PatchTagUnprocessableEntityException
     * @throws Exception\PatchTagTooManyRequestsException
     * @throws Exception\PatchTagServiceUnavailableException
     */
    public function patchTag(?Model\TagsTagPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchTag($requestBody), $fetch);
    }

    /**
     * Returns details about a specific task
     * ## Scopes
     * - `tasks`
     * - `tasks:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $task[id] All 'task[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\TasksTaskGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetTaskBadRequestException
     * @throws Exception\GetTaskForbiddenException
     * @throws Exception\GetTaskNotFoundException
     * @throws Exception\GetTaskTooManyRequestsException
     * @throws Exception\GetTaskServiceUnavailableException
     */
    public function getTask(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetTask($queryParameters), $fetch);
    }

    /**
     * Provides a full list of all trash objects for a specific organization
     * ## Scopes
     * - `trash_objects:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to find all trash objects for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to find all trash objects for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationTrashObjectsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationTrashObjectsBadRequestException
     * @throws Exception\GetOrganizationTrashObjectsForbiddenException
     * @throws Exception\GetOrganizationTrashObjectsNotFoundException
     * @throws Exception\GetOrganizationTrashObjectsTooManyRequestsException
     * @throws Exception\GetOrganizationTrashObjectsServiceUnavailableException
     */
    public function getOrganizationTrashObjects(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationTrashObjects($queryParameters), $fetch);
    }

    /**
     * Purge all trash objects for an organization
     * ## Scopes
     * - `trash_objects:purge`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationTrashObjectsPurgeAllPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationTrashObjectsPurgeAllBadRequestException
     * @throws Exception\PostOrganizationTrashObjectsPurgeAllForbiddenException
     * @throws Exception\PostOrganizationTrashObjectsPurgeAllNotFoundException
     * @throws Exception\PostOrganizationTrashObjectsPurgeAllNotAcceptableException
     * @throws Exception\PostOrganizationTrashObjectsPurgeAllTooManyRequestsException
     * @throws Exception\PostOrganizationTrashObjectsPurgeAllServiceUnavailableException
     */
    public function postOrganizationTrashObjectsPurgeAll(?Model\OrganizationsOrganizationTrashObjectsPurgeAllPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationTrashObjectsPurgeAll($requestBody), $fetch);
    }

    /**
     * Purge a specific trash object
     * ## Scopes
     * - `trash_objects:purge`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\TrashObjectsTrashObjectDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteTrashObjectBadRequestException
     * @throws Exception\DeleteTrashObjectForbiddenException
     * @throws Exception\DeleteTrashObjectNotFoundException
     * @throws Exception\DeleteTrashObjectNotAcceptableException
     * @throws Exception\DeleteTrashObjectTooManyRequestsException
     * @throws Exception\DeleteTrashObjectServiceUnavailableException
     */
    public function deleteTrashObject(?Model\TrashObjectsTrashObjectDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteTrashObject($requestBody), $fetch);
    }

    /**
     * Provides information on a specific trash object
     * ## Scopes
     * - `trash_objects:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $trash_object[id] The trash object to find. All 'trash_object[]' params are mutually exclusive, only one can be provided.
     * @var string $trash_object[object_id] The trash object to find. All 'trash_object[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\TrashObjectsTrashObjectGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetTrashObjectBadRequestException
     * @throws Exception\GetTrashObjectForbiddenException
     * @throws Exception\GetTrashObjectNotFoundException
     * @throws Exception\GetTrashObjectTooManyRequestsException
     * @throws Exception\GetTrashObjectServiceUnavailableException
     */
    public function getTrashObject(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetTrashObject($queryParameters), $fetch);
    }

    /**
     * Restore a trashed object to its original location
     * ## Scopes
     * - `trash_objects:restore`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\TrashObjectsTrashObjectRestorePostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostTrashObjectRestoreBadRequestException
     * @throws Exception\PostTrashObjectRestoreForbiddenException
     * @throws Exception\PostTrashObjectRestoreNotFoundException
     * @throws Exception\PostTrashObjectRestoreTooManyRequestsException
     * @throws Exception\PostTrashObjectRestoreServiceUnavailableException
     */
    public function postTrashObjectRestore(?Model\TrashObjectsTrashObjectRestorePostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostTrashObjectRestore($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\UsersCurrentGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetUsersCurrentBadRequestException
     * @throws Exception\GetUsersCurrentForbiddenException
     * @throws Exception\GetUsersCurrentNotFoundException
     * @throws Exception\GetUsersCurrentTooManyRequestsException
     * @throws Exception\GetUsersCurrentServiceUnavailableException
     */
    public function getUsersCurrent(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetUsersCurrent(), $fetch);
    }

    /**
     * This endpoint allows you to invalidate the web session which is associated with your authenticated
     * identity. This will only work for API identities (most likely API tokens) that were generated using the first-party application
     * login flow.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\InvalidateLinkedWebSessionPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostInvalidateLinkedWebSessionBadRequestException
     * @throws Exception\PostInvalidateLinkedWebSessionForbiddenException
     * @throws Exception\PostInvalidateLinkedWebSessionTooManyRequestsException
     * @throws Exception\PostInvalidateLinkedWebSessionServiceUnavailableException
     */
    public function postInvalidateLinkedWebSession(?Model\InvalidateLinkedWebSessionPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostInvalidateLinkedWebSession($requestBody), $fetch);
    }

    /**
     * Return a list of all virtual machine groups for an organization
     * ## Scopes
     * - `virtual_machine_groups`
     * - `virtual_machine_groups:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] The organization to return groups for. All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] The organization to return groups for. All 'organization[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationVirtualMachineGroupsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationVirtualMachineGroupsBadRequestException
     * @throws Exception\GetOrganizationVirtualMachineGroupsForbiddenException
     * @throws Exception\GetOrganizationVirtualMachineGroupsNotFoundException
     * @throws Exception\GetOrganizationVirtualMachineGroupsTooManyRequestsException
     * @throws Exception\GetOrganizationVirtualMachineGroupsServiceUnavailableException
     */
    public function getOrganizationVirtualMachineGroups(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationVirtualMachineGroups($queryParameters), $fetch);
    }

    /**
     * Create a new virtual machine group with the provided details
     * ## Scopes
     * - `virtual_machine_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationVirtualMachineGroupsPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationVirtualMachineGroupsBadRequestException
     * @throws Exception\PostOrganizationVirtualMachineGroupsForbiddenException
     * @throws Exception\PostOrganizationVirtualMachineGroupsNotFoundException
     * @throws Exception\PostOrganizationVirtualMachineGroupsUnprocessableEntityException
     * @throws Exception\PostOrganizationVirtualMachineGroupsTooManyRequestsException
     * @throws Exception\PostOrganizationVirtualMachineGroupsServiceUnavailableException
     */
    public function postOrganizationVirtualMachineGroups(?Model\OrganizationsOrganizationVirtualMachineGroupsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationVirtualMachineGroups($requestBody), $fetch);
    }

    /**
     * ## Scopes
     * - `virtual_machine_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineGroupsVirtualMachineGroupDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteVirtualMachineGroupBadRequestException
     * @throws Exception\DeleteVirtualMachineGroupForbiddenException
     * @throws Exception\DeleteVirtualMachineGroupNotFoundException
     * @throws Exception\DeleteVirtualMachineGroupConflictException
     * @throws Exception\DeleteVirtualMachineGroupTooManyRequestsException
     * @throws Exception\DeleteVirtualMachineGroupServiceUnavailableException
     */
    public function deleteVirtualMachineGroup(?Model\VirtualMachineGroupsVirtualMachineGroupDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteVirtualMachineGroup($requestBody), $fetch);
    }

    /**
     * Return detailed information about a virtual machine group
     * ## Scopes
     * - `virtual_machine_groups`
     * - `virtual_machine_groups:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine_group[id] The virtual machine group to retrieve. All 'virtual_machine_group[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineGroupsVirtualMachineGroupGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineGroupBadRequestException
     * @throws Exception\GetVirtualMachineGroupForbiddenException
     * @throws Exception\GetVirtualMachineGroupNotFoundException
     * @throws Exception\GetVirtualMachineGroupTooManyRequestsException
     * @throws Exception\GetVirtualMachineGroupServiceUnavailableException
     */
    public function getVirtualMachineGroup(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachineGroup($queryParameters), $fetch);
    }

    /**
     * Update a virtual machine group with the provided details
     * ## Scopes
     * - `virtual_machine_groups`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineGroupsVirtualMachineGroupPatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchVirtualMachineGroupBadRequestException
     * @throws Exception\PatchVirtualMachineGroupForbiddenException
     * @throws Exception\PatchVirtualMachineGroupNotFoundException
     * @throws Exception\PatchVirtualMachineGroupUnprocessableEntityException
     * @throws Exception\PatchVirtualMachineGroupTooManyRequestsException
     * @throws Exception\PatchVirtualMachineGroupServiceUnavailableException
     */
    public function patchVirtualMachineGroup(?Model\VirtualMachineGroupsVirtualMachineGroupPatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchVirtualMachineGroup($requestBody), $fetch);
    }

    /**
     * Returns a list of virtual machine network interfaces
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine[id] The virtual machine to show network interfaces for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var string $virtual_machine[fqdn] The virtual machine to show network interfaces for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineNetworkInterfacesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineNetworkInterfacesBadRequestException
     * @throws Exception\GetVirtualMachineNetworkInterfacesForbiddenException
     * @throws Exception\GetVirtualMachineNetworkInterfacesNotFoundException
     * @throws Exception\GetVirtualMachineNetworkInterfacesNotAcceptableException
     * @throws Exception\GetVirtualMachineNetworkInterfacesTooManyRequestsException
     * @throws Exception\GetVirtualMachineNetworkInterfacesServiceUnavailableException
     */
    public function getVirtualMachineNetworkInterfaces(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachineNetworkInterfaces($queryParameters), $fetch);
    }

    /**
     * Return information about a virtual machine network interface for a specific network
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine[id] The virtual machine to find the network interface for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var string $virtual_machine[fqdn] The virtual machine to find the network interface for. All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     * @var string $network[id] The network to find the network interface for. All 'network[]' params are mutually exclusive, only one can be provided.
     * @var string $network[permalink] The network to find the network interface for. All 'network[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineNetworksNetworkInterfaceGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineNetworkInterfaceBadRequestException
     * @throws Exception\GetVirtualMachineNetworkInterfaceForbiddenException
     * @throws Exception\GetVirtualMachineNetworkInterfaceNotFoundException
     * @throws Exception\GetVirtualMachineNetworkInterfaceNotAcceptableException
     * @throws Exception\GetVirtualMachineNetworkInterfaceTooManyRequestsException
     * @throws Exception\GetVirtualMachineNetworkInterfaceServiceUnavailableException
     */
    public function getVirtualMachineNetworkInterface(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachineNetworkInterface($queryParameters), $fetch);
    }

    /**
     * Return information about a given virtual machine network interface
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine_network_interface[id] The network interface to show the information for. All 'virtual_machine_network_interface[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVMNIVMNIBadRequestException
     * @throws Exception\GetVMNIVMNIForbiddenException
     * @throws Exception\GetVMNIVMNINotFoundException
     * @throws Exception\GetVMNIVMNITooManyRequestsException
     * @throws Exception\GetVMNIVMNIServiceUnavailableException
     */
    public function getVMNIVMNI(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVMNIVMNI($queryParameters), $fetch);
    }

    /**
     * Returns a list of IP addresses that can be allocated to a specific network interface
     * ## Scopes
     * - `ip_addresses`
     * - `ip_addresses:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine_network_interface[id] The network interface to get IP addresses for. All 'virtual_machine_network_interface[]' params are mutually exclusive, only one can be provided.
     * @var string $address_version The IP address version to return results for
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceAvailableIpsAddressVersionGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineNetworkInterfaceAvailableIpsAddressVersionBadRequestException
     * @throws Exception\GetVirtualMachineNetworkInterfaceAvailableIpsAddressVersionForbiddenException
     * @throws Exception\GetVirtualMachineNetworkInterfaceAvailableIpsAddressVersionNotFoundException
     * @throws Exception\GetVirtualMachineNetworkInterfaceAvailableIpsAddressVersionTooManyRequestsException
     * @throws Exception\GetVirtualMachineNetworkInterfaceAvailableIpsAddressVersionServiceUnavailableException
     */
    public function getVirtualMachineNetworkInterfaceAvailableIpsAddressVersion(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachineNetworkInterfaceAvailableIpsAddressVersion($queryParameters), $fetch);
    }

    /**
     * Allocate a specific IP address to a given network interface
     * ## Scopes
     * - `ip_addresses`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceAllocateIpPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateIpBadRequestException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateIpForbiddenException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateIpNotFoundException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateIpUnprocessableEntityException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateIpTooManyRequestsException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateIpServiceUnavailableException
     */
    public function postVirtualMachineNetworkInterfaceAllocateIp(?Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceAllocateIpPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineNetworkInterfaceAllocateIp($requestBody), $fetch);
    }

    /**
     * Add a new IP address to this organization and allocate it to a virtual machine network interface
     * ## Scopes
     * - `ip_addresses`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceAllocateNewIpPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateNewIpBadRequestException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateNewIpForbiddenException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateNewIpNotFoundException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateNewIpTooManyRequestsException
     * @throws Exception\PostVirtualMachineNetworkInterfaceAllocateNewIpServiceUnavailableException
     */
    public function postVirtualMachineNetworkInterfaceAllocateNewIp(?Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceAllocateNewIpPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineNetworkInterfaceAllocateNewIp($requestBody), $fetch);
    }

    /**
     * ## Scopes
     * - `virtual_machines`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceUpdateSpeedProfilePatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfileBadRequestException
     * @throws Exception\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfileForbiddenException
     * @throws Exception\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfileNotFoundException
     * @throws Exception\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfileNotAcceptableException
     * @throws Exception\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfileUnprocessableEntityException
     * @throws Exception\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfileTooManyRequestsException
     * @throws Exception\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfileServiceUnavailableException
     */
    public function patchVirtualMachineNetworkInterfaceUpdateSpeedProfile(?Model\VirtualMachineNetworkInterfacesVirtualMachineNetworkInterfaceUpdateSpeedProfilePatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchVirtualMachineNetworkInterfaceUpdateSpeedProfile($requestBody), $fetch);
    }

    /**
     * Returns a list of virtual machine packages
     * ## Scopes
     * - `virtual_machine_packages:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] Provide an organization to only show packages available to the given organization (otherwise only public packages will be displayed). All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var string $organization[sub_domain] Provide an organization to only show packages available to the given organization (otherwise only public packages will be displayed). All 'organization[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinePackagesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachinePackagesBadRequestException
     * @throws Exception\GetVirtualMachinePackagesForbiddenException
     * @throws Exception\GetVirtualMachinePackagesNotFoundException
     * @throws Exception\GetVirtualMachinePackagesTooManyRequestsException
     * @throws Exception\GetVirtualMachinePackagesServiceUnavailableException
     */
    public function getVirtualMachinePackages(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachinePackages($queryParameters), $fetch);
    }

    /**
     * Return information about a given virtual machine package
     * ## Scopes
     * - `virtual_machine_packages:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine_package[id] All 'virtual_machine_package[]' params are mutually exclusive, only one can be provided
     * @var string $virtual_machine_package[permalink] All 'virtual_machine_package[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinePackagesVirtualMachinePackageGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachinePackageBadRequestException
     * @throws Exception\GetVirtualMachinePackageForbiddenException
     * @throws Exception\GetVirtualMachinePackageNotFoundException
     * @throws Exception\GetVirtualMachinePackageTooManyRequestsException
     * @throws Exception\GetVirtualMachinePackageServiceUnavailableException
     */
    public function getVirtualMachinePackage(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachinePackage($queryParameters), $fetch);
    }

    /**
     * Returns a list of all virtual machines for a given organization
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $organization[id] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $organization[sub_domain] All 'organization[]' params are mutually exclusive, only one can be provided
     * @var string $annotations[key] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var string $annotations[value] An array of annotations to filter by. All 'annotations[]' params are mutually exclusive, only one can be provided.
     * @var int    $page
     * @var int    $per_page
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationVirtualMachinesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetOrganizationVirtualMachinesBadRequestException
     * @throws Exception\GetOrganizationVirtualMachinesForbiddenException
     * @throws Exception\GetOrganizationVirtualMachinesNotFoundException
     * @throws Exception\GetOrganizationVirtualMachinesTooManyRequestsException
     * @throws Exception\GetOrganizationVirtualMachinesServiceUnavailableException
     */
    public function getOrganizationVirtualMachines(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetOrganizationVirtualMachines($queryParameters), $fetch);
    }

    /**
     * Moves an existing virtual machine to the trash
     * ## Scopes
     * - `virtual_machines`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineDeleteResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\DeleteVirtualMachineBadRequestException
     * @throws Exception\DeleteVirtualMachineForbiddenException
     * @throws Exception\DeleteVirtualMachineNotFoundException
     * @throws Exception\DeleteVirtualMachineNotAcceptableException
     * @throws Exception\DeleteVirtualMachineTooManyRequestsException
     * @throws Exception\DeleteVirtualMachineServiceUnavailableException
     */
    public function deleteVirtualMachine(?Model\VirtualMachinesVirtualMachineDeleteBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\DeleteVirtualMachine($requestBody), $fetch);
    }

    /**
     * Return information about a virtual machine
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine[id] All 'virtual_machine[]' params are mutually exclusive, only one can be provided
     * @var string $virtual_machine[fqdn] All 'virtual_machine[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineBadRequestException
     * @throws Exception\GetVirtualMachineForbiddenException
     * @throws Exception\GetVirtualMachineNotFoundException
     * @throws Exception\GetVirtualMachineNotAcceptableException
     * @throws Exception\GetVirtualMachineTooManyRequestsException
     * @throws Exception\GetVirtualMachineServiceUnavailableException
     */
    public function getVirtualMachine(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachine($queryParameters), $fetch);
    }

    /**
     * Update the properties of a virtual machine
     * ## Scopes
     * - `virtual_machines`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachinePatchResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PatchVirtualMachineBadRequestException
     * @throws Exception\PatchVirtualMachineForbiddenException
     * @throws Exception\PatchVirtualMachineNotFoundException
     * @throws Exception\PatchVirtualMachineNotAcceptableException
     * @throws Exception\PatchVirtualMachineTooManyRequestsException
     * @throws Exception\PatchVirtualMachineServiceUnavailableException
     */
    public function patchVirtualMachine(?Model\VirtualMachinesVirtualMachinePatchBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PatchVirtualMachine($requestBody), $fetch);
    }

    /**
     * Change a package for a virtual machine
     * ## Scopes
     * - `virtual_machines`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachinePackagePutResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PutVirtualMachinePackageBadRequestException
     * @throws Exception\PutVirtualMachinePackageForbiddenException
     * @throws Exception\PutVirtualMachinePackageNotFoundException
     * @throws Exception\PutVirtualMachinePackageNotAcceptableException
     * @throws Exception\PutVirtualMachinePackageTooManyRequestsException
     * @throws Exception\PutVirtualMachinePackageServiceUnavailableException
     */
    public function putVirtualMachinePackage(?Model\VirtualMachinesVirtualMachinePackagePutBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PutVirtualMachinePackage($requestBody), $fetch);
    }

    /**
     * Change the flexible resources assigned to a virtual machine
     * ## Scopes
     * - `virtual_machines`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineFlexibleResourcesPutResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PutVirtualMachineFlexibleResourcesBadRequestException
     * @throws Exception\PutVirtualMachineFlexibleResourcesForbiddenException
     * @throws Exception\PutVirtualMachineFlexibleResourcesNotFoundException
     * @throws Exception\PutVirtualMachineFlexibleResourcesNotAcceptableException
     * @throws Exception\PutVirtualMachineFlexibleResourcesTooManyRequestsException
     * @throws Exception\PutVirtualMachineFlexibleResourcesServiceUnavailableException
     */
    public function putVirtualMachineFlexibleResources(?Model\VirtualMachinesVirtualMachineFlexibleResourcesPutBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PutVirtualMachineFlexibleResources($requestBody), $fetch);
    }

    /**
     * Allocate an IP address to a virtual machine, automatically determining the network interface
     * ## Scopes
     * - `ip_addresses`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineAllocateIpPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineAllocateIpBadRequestException
     * @throws Exception\PostVirtualMachineAllocateIpForbiddenException
     * @throws Exception\PostVirtualMachineAllocateIpNotFoundException
     * @throws Exception\PostVirtualMachineAllocateIpNotAcceptableException
     * @throws Exception\PostVirtualMachineAllocateIpUnprocessableEntityException
     * @throws Exception\PostVirtualMachineAllocateIpTooManyRequestsException
     * @throws Exception\PostVirtualMachineAllocateIpServiceUnavailableException
     */
    public function postVirtualMachineAllocateIp(?Model\VirtualMachinesVirtualMachineAllocateIpPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineAllocateIp($requestBody), $fetch);
    }

    /**
     * Return the authorized keys for the virtual machine associated with the provided API token
     * ## Scopes
     * - `virtual_machines:authorized_keys`.
     *
     * @param string $fetch  Fetch mode to use (can be OBJECT or RESPONSE)
     * @param array  $accept Accept content header text/plain|application/json
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachineAuthorizedKeysBadRequestException
     * @throws Exception\GetVirtualMachineAuthorizedKeysForbiddenException
     * @throws Exception\GetVirtualMachineAuthorizedKeysNotFoundException
     * @throws Exception\GetVirtualMachineAuthorizedKeysTooManyRequestsException
     * @throws Exception\GetVirtualMachineAuthorizedKeysServiceUnavailableException
     */
    public function getVirtualMachineAuthorizedKeys(string $fetch = self::FETCH_OBJECT, array $accept = [])
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachineAuthorizedKeys($accept), $fetch);
    }

    /**
     * Builds a new virtual machine based on the arguments provided to this endpoint. Virtual machines will be built in the background. This task will return an task object that will allow you to monitor the build process using the appropriate API action. This action only offers a small subset of the full functionality needed when provisioning virtual machines - see the `build_from_spec` action for a full advanced virtual machine creation method.
     * ## Scopes
     * - `virtual_machines`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationVirtualMachinesBuildPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationVirtualMachinesBuildBadRequestException
     * @throws Exception\PostOrganizationVirtualMachinesBuildForbiddenException
     * @throws Exception\PostOrganizationVirtualMachinesBuildNotFoundException
     * @throws Exception\PostOrganizationVirtualMachinesBuildUnprocessableEntityException
     * @throws Exception\PostOrganizationVirtualMachinesBuildTooManyRequestsException
     * @throws Exception\PostOrganizationVirtualMachinesBuildServiceUnavailableException
     */
    public function postOrganizationVirtualMachinesBuild(?Model\OrganizationsOrganizationVirtualMachinesBuildPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationVirtualMachinesBuild($requestBody), $fetch);
    }

    /**
     * Builds a new virtual machine by receiving a virtual machine spec document
     * ## Scopes
     * - `virtual_machines`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\OrganizationsOrganizationVirtualMachinesBuildFromSpecPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostOrganizationVirtualMachinesBuildFromSpecBadRequestException
     * @throws Exception\PostOrganizationVirtualMachinesBuildFromSpecForbiddenException
     * @throws Exception\PostOrganizationVirtualMachinesBuildFromSpecNotFoundException
     * @throws Exception\PostOrganizationVirtualMachinesBuildFromSpecUnprocessableEntityException
     * @throws Exception\PostOrganizationVirtualMachinesBuildFromSpecTooManyRequestsException
     * @throws Exception\PostOrganizationVirtualMachinesBuildFromSpecServiceUnavailableException
     */
    public function postOrganizationVirtualMachinesBuildFromSpec(?Model\OrganizationsOrganizationVirtualMachinesBuildFromSpecPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostOrganizationVirtualMachinesBuildFromSpec($requestBody), $fetch);
    }

    /**
     * Return virtual machine build information
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:read`.
     *
     * @param array $queryParameters {
     *
     * @var string $virtual_machine_build[id] All 'virtual_machine_build[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesBuildsVirtualMachineBuildGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetVirtualMachinesBuildsVirtualMachineBuildBadRequestException
     * @throws Exception\GetVirtualMachinesBuildsVirtualMachineBuildForbiddenException
     * @throws Exception\GetVirtualMachinesBuildsVirtualMachineBuildNotFoundException
     * @throws Exception\GetVirtualMachinesBuildsVirtualMachineBuildTooManyRequestsException
     * @throws Exception\GetVirtualMachinesBuildsVirtualMachineBuildServiceUnavailableException
     */
    public function getVirtualMachinesBuildsVirtualMachineBuild(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetVirtualMachinesBuildsVirtualMachineBuild($queryParameters), $fetch);
    }

    /**
     * Queues a task to start a virtual machine
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:power_actions`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineStartPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineStartBadRequestException
     * @throws Exception\PostVirtualMachineStartForbiddenException
     * @throws Exception\PostVirtualMachineStartNotFoundException
     * @throws Exception\PostVirtualMachineStartNotAcceptableException
     * @throws Exception\PostVirtualMachineStartTooManyRequestsException
     * @throws Exception\PostVirtualMachineStartServiceUnavailableException
     */
    public function postVirtualMachineStart(?Model\VirtualMachinesVirtualMachineStartPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineStart($requestBody), $fetch);
    }

    /**
     * Queues a task to stop a virtual machine
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:power_actions`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineStopPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineStopBadRequestException
     * @throws Exception\PostVirtualMachineStopForbiddenException
     * @throws Exception\PostVirtualMachineStopNotFoundException
     * @throws Exception\PostVirtualMachineStopNotAcceptableException
     * @throws Exception\PostVirtualMachineStopTooManyRequestsException
     * @throws Exception\PostVirtualMachineStopServiceUnavailableException
     */
    public function postVirtualMachineStop(?Model\VirtualMachinesVirtualMachineStopPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineStop($requestBody), $fetch);
    }

    /**
     * Queues a task to shutdown a virtual machine
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:power_actions`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineShutdownPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineShutdownBadRequestException
     * @throws Exception\PostVirtualMachineShutdownForbiddenException
     * @throws Exception\PostVirtualMachineShutdownNotFoundException
     * @throws Exception\PostVirtualMachineShutdownNotAcceptableException
     * @throws Exception\PostVirtualMachineShutdownTooManyRequestsException
     * @throws Exception\PostVirtualMachineShutdownServiceUnavailableException
     */
    public function postVirtualMachineShutdown(?Model\VirtualMachinesVirtualMachineShutdownPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineShutdown($requestBody), $fetch);
    }

    /**
     * Queues a task to reset a virtual machine
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:power_actions`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineResetPostResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineResetBadRequestException
     * @throws Exception\PostVirtualMachineResetForbiddenException
     * @throws Exception\PostVirtualMachineResetNotFoundException
     * @throws Exception\PostVirtualMachineResetNotAcceptableException
     * @throws Exception\PostVirtualMachineResetTooManyRequestsException
     * @throws Exception\PostVirtualMachineResetServiceUnavailableException
     */
    public function postVirtualMachineReset(?Model\VirtualMachinesVirtualMachineResetPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineReset($requestBody), $fetch);
    }

    /**
     * Creates a new console session which can be opened in a browser
     * ## Scopes
     * - `virtual_machines`
     * - `virtual_machines:console`.
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\VirtualMachinesVirtualMachineConsoleSessionsPostResponse201|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\PostVirtualMachineConsoleSessionsBadRequestException
     * @throws Exception\PostVirtualMachineConsoleSessionsForbiddenException
     * @throws Exception\PostVirtualMachineConsoleSessionsNotFoundException
     * @throws Exception\PostVirtualMachineConsoleSessionsNotAcceptableException
     * @throws Exception\PostVirtualMachineConsoleSessionsUnprocessableEntityException
     * @throws Exception\PostVirtualMachineConsoleSessionsTooManyRequestsException
     * @throws Exception\PostVirtualMachineConsoleSessionsServiceUnavailableException
     */
    public function postVirtualMachineConsoleSessions(?Model\VirtualMachinesVirtualMachineConsoleSessionsPostBody $requestBody = null, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\PostVirtualMachineConsoleSessions($requestBody), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ZonesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetZonesBadRequestException
     * @throws Exception\GetZonesForbiddenException
     * @throws Exception\GetZonesTooManyRequestsException
     * @throws Exception\GetZonesServiceUnavailableException
     */
    public function getZones(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetZones(), $fetch);
    }

    /**
     * Returns the details for a specific zone.
     *
     * @param array $queryParameters {
     *
     * @var string $zone[id] The zone to find. All 'zone[]' params are mutually exclusive, only one can be provided.
     * @var string $zone[permalink] The zone to find. All 'zone[]' params are mutually exclusive, only one can be provided.
     *             }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @return Model\ZonesZoneGetResponse200|\Psr\Http\Message\ResponseInterface|null
     *
     * @throws Exception\GetZoneBadRequestException
     * @throws Exception\GetZoneForbiddenException
     * @throws Exception\GetZoneNotFoundException
     * @throws Exception\GetZoneTooManyRequestsException
     * @throws Exception\GetZoneServiceUnavailableException
     */
    public function getZone(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new Endpoint\GetZone($queryParameters), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [], array $additionalNormalizers = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            $uri = \Http\Discovery\Psr17FactoryDiscovery::findUriFactory()->createUri('https://api.katapult.io/core/v1');
            $plugins[] = new \Http\Client\Common\Plugin\AddHostPlugin($uri);
            $plugins[] = new \Http\Client\Common\Plugin\AddPathPlugin($uri);
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $normalizers = [new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new Normalizer\JaneObjectNormalizer()];
        if (count($additionalNormalizers) > 0) {
            $normalizers = array_merge($normalizers, $additionalNormalizers);
        }
        $serializer = new \Symfony\Component\Serializer\Serializer($normalizers, [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
